# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16HeYOvInBETRENm9eIoLpeu2YC4ABXjb
"""

from google.colab import drive
drive.mount("/content/drive")

!apt-get install libgeos-3.5.0
!apt-get install libgeos-dev
!pip install https://github.com/matplotlib/basemap/archive/master.zip
!pip install http://sourceforge.net/projects/matplotlib/files/matplotlib-toolkits/

!pip install netcdf4
!pip install pyMCR
!pip install geopandas

"""# Libraries"""

#!/bin/env python
import sys
import glob
import os
import re
import numpy as np
import numpy.ma as ma
import matplotlib
#matplotlib.use('Agg')
import matplotlib.pyplot as plt
#plt.rcParams.update({'figure.max_open_warning': 0})
import matplotlib.colors as mcolors
from matplotlib.colors import ListedColormap
from scipy.interpolate import griddata
import torch
from mpl_toolkits.mplot3d import Axes3D
from PIL import Image
from skimage import measure, transform
#from skimage.segmentation import slic
#from skimage.segmentation import mark_boundaries
from skimage import io
from skimage import data, segmentation, color
from scipy.ndimage import label, generate_binary_structure
from scipy.spatial import distance
from scipy import ndimage
from shapely.geometry import Point, LineString, Polygon, LinearRing, MultiPoint
from descartes import PolygonPatch
import networkx as nx
import tarfile
import string
import calendar
import cv2
import random
from google.colab.patches import cv2_imshow
from mpl_toolkits.basemap import Basemap,cm
from mpl_toolkits.axes_grid1 import make_axes_locatable
import netCDF4
from geopandas import GeoSeries
from sklearn.neighbors import NearestNeighbors
from sklearn.cluster import KMeans
import seaborn as sns
from scipy.signal import find_peaks
from sklearn.metrics import confusion_matrix, accuracy_score

DIR_DATA = '/content/drive/MyDrive/StageUParis/DATA/H2O/'
DIR_TRAIN = '/content/drive/MyDrive/StageUParis/DATA/LABELS/'
DIR_TEST = '/content/drive/MyDrive/StageUParis/Test/'

"""# Class **SplitImageLevels**"""

class SplitImageLevels():  
  image_type = "LT"
  year = 2008
  month = 5
  day = 1

  degree = 0.625
  pixel_size = 0.3125
  vmax = 35
  vmin = 0

  weight_gray_values = 1
  N_CLUSTERS = 2

  images = list()

  def __init__ (self,DIR_DATA=DIR_DATA, DIR_TRAIN=DIR_TRAIN):
    self.DIR_DATA = DIR_DATA
    self.DIR_TRAIN = DIR_TRAIN

  def __del__(self):
    print("Class finished")


  ############################################################################
  ####                      GETTERS AND SETTERS
  ############################################################################

  def set_DIR_DATA (self, DIR_DATA):
    self.DIR_DATA = DIR_DATA

  def get_DIR_DATA (self):
    return self.DIR_DATA

  def set_DIR_TRAIN (self, DIR_TRAIN):
    self.DIR_TRAIN = DIR_TRAIN
  
  def get_DIR_TRAIN (self):
    return self.DIR_TRAIN

  def set_DIR_TEST (self, DIR_TEST):
    self.DIR_TEST = DIR_TEST

  def get_DIR_TEST (self):
    return self.DIR_TEST

  def set_year(self,year):
    self.year = year

  def get_year(self):
    return self.year
  
  def set_month(self,month):
    self.month = month
  
  def get_month(self):
    return self.month

  def set_day(self,day):
    self.day = day

  def get_day(self):
    return self.day

  def set_image_type(self,image_type):
    self.image_type = image_type

  def get_image_type(self):
    return self.image_type

  def set_image_name(self,image_name):
    self.image_name = image_name

  def get_image_name(self):
    return self.image_name

  def set_pixel_size(self, degree, size):
    self.degree = degree
    self.pixel_size = size

  def set_region_area(self, max_area, min_area):
    self.max_area = max_area
    self.min_area = min_area

  def set_weight_gray_values(self, weight_gray_values):
    self.weight_gray_values = weight_gray_values

  def set_cluster_value (self, N_CLUSTERS):
    self.N_CLUSTERS = N_CLUSTERS

  def get_cluster_value(self):
    return self.N_CLUSTERS






  ############################################################################
  ####                        READ THE DATA
  ############################################################################

  def get_image_by_leves (self):
    #for index, layer in enumerate(np.arange(self.start, self.end, self.steps)):
    index = 0
    
    lat_g = np.arange(20.,50.,self.degree)
    lon_g = np.arange(100.,150.,self.degree)

    #initialization
    self.colgrid = np.zeros([lat_g.shape[0],lon_g.shape[0]], np.uint8)

    for year in range(self.year, self.year + 1):
      for month in range(self.month, self.month + 1):
        for day in range(self.day, self.day + 1):

          fname = self.DIR_DATA + 'IASIdaily_' + str(year) + '%02d'%month+'%02d'%day+'.nc'
          self.image_name = self.image_type + '-level-' + str(year) + '%02d'%month+'%02d'%day+'.png'

          print('reading info ...')

          if not(os.path.isfile(fname)):
            continue

          nc = netCDF4.Dataset(fname)
          flag = nc.variables['flag'][:]
          mask1 = (flag == 0) # Without clouds
          
          lat = nc.variables['lat'][mask1]
          lon = nc.variables['lon'][mask1]
          col = nc.variables[self.image_type][mask1]
          nc.close()

          mask2 = (np.isnan(col) == False) 

          # gridding the data
          for ilat in range(lat_g.shape[0]):
            for ilon in range(lon_g.shape[0]):
              # Grille régulier
              # 25 km
              # 0 25 degrée lattitude et longitude

              # Grille regulier of 0.125 degree
              maskgrid = (lat[:] >= (lat_g[ilat] - self.pixel_size)) & (lat[:] < (lat_g[ilat] + self.pixel_size)) & (lon[:] >= (lon_g[ilon] - self.pixel_size)) & (lon[:] < (lon_g[ilon] + self.pixel_size))
              
              # Defining invalid data
              mask = mask2 & maskgrid

              if len(col[mask]) != 0:
                median = np.mean(col[mask])
                #if median >= layer:
                self.colgrid[ilat,ilon] = median

          print('data readed correctly')

          # We mark the values at colgrid as invalid because they are maybe false positives or bad sampling
          self.colgrid1 = ma.masked_values(self.colgrid, 0.)

          self.v_x, self.v_y = np.meshgrid(lon_g, lat_g)
          gradx, grady = np.gradient(self.colgrid, edge_order=1)

          fig, (ax1) = plt.subplots(1, 1, figsize = (11,8))
          ax1.pcolormesh(self.v_x, self.v_y, self.colgrid, shading='nearest',cmap='gray', vmin=self.vmin, vmax=self.vmax)
          ax1.axis('off')
          fig.savefig(self.image_name, bbox_inches='tight', pad_inches=0)
          plt.close(fig)


          fig2, (ax2) = plt.subplots(1, 1, figsize = (11,8))
          ax2.pcolormesh(self.v_x, self.v_y, self.colgrid1, shading='nearest',cmap='jet', vmin=self.vmin, vmax=self.vmax)
          ax2.axis('off')
          fig2.savefig("color-" + self.image_name, bbox_inches='tight', pad_inches=0)
          plt.close(fig2)








  ###############################################################
  ###             LOAD IMAGE INFORMATION
  ###############################################################

  def load_image_from_files (self, filename):
    img_bgr = io.imread(filename) 
    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)

    return img_bgr, gray



  def process_set_images(self, image, image_color):
    image, _, background = self.filter_image(image)
    regions, _ = self.get_mser_regions(image)
    
    regx, regy, polys, lines, values = self.set_mser_regions(image, background, regions[:])
    #self.divide_regions(image,regx, regy, polys, lines, values)
    labels, centers = self.classify_neighbors(image, regx, regy,polys, values)
    self.plot_mser_final_regions(image, regx, regy, values)
    
    #self.show_mser_red_regions(image, regions[:], labels)
    #polys = self.classify_regions(image,poly[:])
    #polys = self.classify_all_regions(image, poly[:])
    #self.plot_mser_regions_3d(regx, regy, values, labels)
    







  ###############################################################
  ###             TRAITEMENT
  ###############################################################

  def get_pollution_image_reference(self, image):

    image_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    
    # Search Pollution:
    reds_colors = np.array([255,0,0], dtype=np.uint8)
    #high_reds_colors = np.array([130, 255, 255], dtype=np.uint8)

    # Search Mix:
    low_blues_colors = np.array([100,65,75], dtype=np.uint8)
    high_blues_colors = np.array([130, 255, 255], dtype=np.uint8)
    
    pollution_mask = cv2.inRange(image_hsv, reds_colors, reds_colors)

    print("pollution mask", pollution_mask)
    
    # Momentos
    #moments = cv2.moments(mascara_azul)
    #area = int(moments['m00'])
    #print("Pixeles activos "+str(area) +" pixeles")


  def resize_image_percentage (self, image, scale_percent = 100):
    ### SCALE
    width = int(image.shape[1] * scale_percent / 100)
    height = int(image.shape[0] * scale_percent / 100)
    dim = (width, height)
    image = cv2.resize(image, dim, interpolation = cv2.INTER_AREA)

    return image

  def normalize_image(self, image):
    return cv2.normalize(image, np.ones((image.shape[0], image.shape[0])) , 0, 255, cv2.NORM_MINMAX )

  def pretraitement_image(self, image, kernel_size = 9, iterations=3):
    ### MORPHO FILTERS
    kernel = np.ones((kernel_size,kernel_size),np.uint8)
    image = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel, iterations = iterations)

    return image

  ## REMOVING THE HOLES
  def masking_interest_region(self, image):
    # Take the holes (pixels value = 0) and set it as 255
    image = cv2.normalize(image, np.ones((image.shape[0], image.shape[0])) , self.vmin, self.vmax, cv2.NORM_MINMAX )
    image = np.where(image == 0, 255, image) 
    image = np.where(image != 255, 0, image) # This is the mask of the background
    image_holes_dilate = cv2.morphologyEx(image, cv2.MORPH_DILATE, np.ones((3,3),np.uint8), iterations = 3)
    image_holes_dilate_inv = cv2.bitwise_not(image_holes_dilate) # This is the mask of the foreground

    return image_holes_dilate, image_holes_dilate_inv

  def find_edges (self, image):
    ## Below code convert image gradient in both x and y direction
    image = cv2.Laplacian(image, cv2.CV_64F, ksize=3) 
    image = np.uint8(np.absolute(image))
    #image_laplacian = cv2.bitwise_and(image_laplacian,image_laplacian,mask = image_holes_dilate_inv)

    return image


  def filter_image (self, image):
    image = self.resize_image_percentage(image, 100)
    image = self.pretraitement_image(image,6,3)
    background, foreground = self.masking_interest_region(image)
    
    return image, foreground, background

  def get_mser_regions(self, image, vmin=300,vmax=50000):
    mser = cv2.MSER_create(1, vmin, vmax, .25, 1., 1000, 1.001, 0.003, 5)
    #(1, 100, 20000, .25, 1., 1000, 1.001, 0.003, 5)
   
    #fig, ax = plt.subplots(1,1)
    #colorinfo = ax.imshow(image, cmap='gray')
    #fig.colorbar(colorinfo)

    regions, bboxes = mser.detectRegions(image)
    regions = sorted(regions, key=cv2.contourArea, reverse=True)

    return regions, bboxes







  ###############################################################
  ###             PLOTTING
  ###############################################################

  def show_mser_red_regions(self, image, regions, labels):
    image = cv2.cvtColor(image, cv2.COLOR_BGRA2BGR)
    #colors = np.array([(255,0,0),[(0,255,0),(0,0,255),(0,255,255),(255,255,0),(100,0,100),(24,180,0)])
    colors = list([(255,0,0),(0,255,0),(0,0,255),(0,255,255),(255,255,0),(100,0,100),(24,180,0)])

    #for i in labels:
    #  print(colors[i])

    #for l in labels:
    for i, p in enumerate(regions[:]):
      if i == (len(regions[:3]) - 1):
        color = (255,0,0)
      elif i == (len(regions[:3]) - 2):
        color = (0,0,255)
      else:
        color = (0,255,0)

      #print("color", color, "for", i)
      for k in p:
        cv2.circle(image, (k[0],k[1]), radius=0, color=color, thickness=-1)

    fig, ax = plt.subplots(1,1)
    ax.imshow(image)
    #ax.invert_yaxis()












  def set_mser_regions(self, image, background, regions):
    regsX = list()
    regsY = list()
    regs = list()
    regsPoly = list()
    regsLine = list()
    values_gray = list()

    for j,r in enumerate(regions):
      region = list()
      hull = cv2.convexHull(r)

      for h in hull:
          region.append(h[0].tolist())

      region.append(region[0])
      poly = Polygon(region)
      line = LineString(region)
      value_pixel = self.get_region_value(image,poly)

      if np.isnan(value_pixel):
        print(value_pixel)
        break
      #xs = [pnt[0] if background[pnt[1],pnt[0]] != 255 else np.nan for pnt in r[:]]
      #ys = [pnt[1] if background[pnt[1],pnt[0]] != 255 else np.nan for pnt in r[:]]
      xs = [pnt[0] for pnt in r]
      ys = [pnt[1] for pnt in r]

      regsX.append(xs)
      regsY.append(ys)
      regs.append(r)
      regsPoly.append(poly)
      regsLine.append(line)
      values_gray.append(value_pixel)

    return regsX, regsY, regs, regsPoly, regsLine, values_gray

  def export_current_region (self, image, regsX, regsY, filename="image-temp.png"):
    x_range = [0, image.shape[1]]
    y_range = [0, image.shape[0]]

    fig, ax1 = plt.subplots(1, 1, figsize=(11,8))
    ax1.scatter(regsX,regsY, cmap="gray")
    ax1.set_xlim(*x_range)
    ax1.set_ylim(*y_range)
    ax1.invert_yaxis()
    ax1.axis('off')
    fig.savefig(filename, bbox_inches='tight', pad_inches=0)
    plt.close(fig)

  def slic_regions(self,image,mask,compactness=50,n_segments=150):
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    # compactness=compactness,
    labels_1 = segmentation.slic(image,n_segments=n_segments)
    out_1 = color.label2rgb(labels_1, image, kind='avg', bg_label=0)
    out_1 = cv2.cvtColor(out_1, cv2.COLOR_RGB2GRAY)
    out_1 = cv2.bitwise_and(out_1,out_1,mask=mask)

    fig, ax = plt.subplots(1, 1)
    ax.imshow(out_1, cmap="gray")
    ax.set_title("SLIC")

    return out_1
    

  def divide_regions(self, image, regx, regy, polys, lines, values):
    xx_range = [0, image.shape[1]]
    yy_range = [0, image.shape[0]]

    areas = list()
    for p in polys:
      areas.append(p.area)

    x_range = [100, 150, 10]
    y_range = [20, 48, 5]

    fig, ax = plt.subplots(1,1)
    m=Basemap(llcrnrlon=100.,llcrnrlat=20.,urcrnrlon=150.,urcrnrlat=48.,resolution='i')
    m.drawcoastlines()
    m.drawmapboundary()
    m.drawmeridians(np.r_[100:151:10], labels=[0,0,0,1], color='grey',fontsize=8,linewidth=0)
    m.drawparallels(np.r_[20:48:5], labels=[1,0,0,0], color='grey',fontsize=8,linewidth=0)

    fig0, ax0 = plt.subplots(1,1)
    fig3, ax3 = plt.subplots(1,1)
    m=Basemap(llcrnrlon=100.,llcrnrlat=20.,urcrnrlon=150.,urcrnrlat=48.,resolution='i')
    m.drawcoastlines()
    m.drawmapboundary()
    m.drawmeridians(np.r_[100:151:10], labels=[0,0,0,1], color='grey',fontsize=8,linewidth=0)
    m.drawparallels(np.r_[20:48:5], labels=[1,0,0,0], color='grey',fontsize=8,linewidth=0)
    for i,line in enumerate(lines):
      area = polys[i].area
      mean_areas = np.mean(areas)
      if area > mean_areas and area > 30000.:
        mean_value = np.mean(values)
        if values[i] > mean_value:
          x, y = line.xy
          filename = "image-temp-"+ str(i) +".png"
          self.export_current_region(image, regx[i] ,regy[i], filename )
          im, im_gray = self.load_image_from_files(filename)
          im_gray = cv2.bitwise_not(im_gray)

          # SLIC
          img_slic = self.slic_regions(image,im_gray)

          img_temp = img_slic.copy()
          img_temp = cv2.cvtColor(img_temp, cv2.COLOR_GRAY2RGB)

          # MSER
          reg2, _ = self.get_mser_regions(img_temp,100,20000)
          #mser = cv2.MSER_create(1, 100, 20000, .25, 1., 1000, 1.001, 0.003, 5)
          #reg2, _ = mser.detectRegions(img_temp)
          #reg2 = sorted(reg2, key=cv2.contourArea, reverse=True)

          #for p in reg2[:]:
          #  for k in p:
          #    cv2.circle(img_temp, (k[0],k[1]), radius=0, color=(0, 0, 255), thickness=-1)
          #ax3.imshow(img_temp)

          # PLOT
          rx, ry, ps, ls, vs = self.set_mser_regions(image, background, reg2)
          
          #self.plot_mser_final_regions(image, rx, ry, vs)
          # OLD REGIONS
          rgsX_2 = list()
          rgsY_2 = list()

          for reg in regx:
            line = list()
            for j in reg:
              line.append((j / (image.shape[1] / 50)) + 100)
            rgsX_2.append(line)

          for reg in regy:
            line = list()
            for j in reg:
              line.append(((image.shape[0] - j) / (image.shape[0] / 28)) + 20)
            rgsY_2.append(line)
          
          if self.image_type == 'LT':
            max_color_value = 35
          else:
            max_color_value = 45
          
          colors = sns.color_palette("YlOrBr", max_color_value + 1)
          cmap_old = matplotlib.colors.ListedColormap(colors)
          norm_old = matplotlib.colors.BoundaryNorm(np.arange(max_color_value + 1) - 0.5, cmap_old.N)

          #for j,val in enumerate(values):
          ax3.scatter(rgsX_2[i], rgsY_2[i], marker='.', color=cmap_old(norm_old(int(values[i]))) )
          ax3.set_xlim(*x_range)
          ax3.set_ylim(*y_range)
          ax3.set_title('OLD Regions - IASI ' + self.image_type + " - " + str(self.day) +"/"+ str(self.month) +"/"+ str(self.year))

          sm_old = matplotlib.cm.ScalarMappable(cmap=cmap_old, norm=norm_old)
          cbar_ax_old = fig.add_axes([0.09, 0.06, 0.84, 0.02])
          cb_old = fig3.colorbar(sm_old,cax=cbar_ax_old,orientation='horizontal')
          if self.image_type == 'LT':
            cb_old.set_ticklabels(np.arange(0,35,4))
          else:
            cb_old.set_ticklabels(np.arange(0,45,5))
          cb_old.set_label('DU')

          # NEW
          ax0.plot(x, y, label="area:" + str(int(area)))
          ax0.set_xlim(*xx_range)
          ax0.set_ylim(*yy_range)
          ax0.invert_yaxis()

          rgsX2 = list()
          rgsY2 = list()

          for reg in rx:
            line = list()
            for i in reg:
              line.append((i / (image.shape[1] / 50)) + 100)
            rgsX2.append(line)

          for reg in ry:
            line = list()
            for i in reg:
              line.append(((image.shape[0] - i) / (image.shape[0] / 28)) + 20)
            rgsY2.append(line)
          
          if self.image_type == 'LT':
            max_color_value = 35
          else:
            max_color_value = 45
          
          colors = sns.color_palette("YlOrBr", max_color_value + 1)
          cmap = matplotlib.colors.ListedColormap(colors)
          norm = matplotlib.colors.BoundaryNorm(np.arange(max_color_value + 1) - 0.5, cmap.N)

          for i,val in enumerate(vs):
            ax.scatter(rgsX2[i], rgsY2[i], marker='.', color=cmap(norm(int(val))) )
            ax.set_xlim(*x_range)
            ax.set_ylim(*y_range)
            ax.set_title('Max Regs - IASI ' + self.image_type + " - " + str(self.day) +"/"+ str(self.month) +"/"+ str(self.year))

          sm = matplotlib.cm.ScalarMappable(cmap=cmap, norm=norm)
          cbar_ax = fig.add_axes([0.09, 0.06, 0.84, 0.02])
          cb = fig.colorbar(sm,cax=cbar_ax,orientation='horizontal')
          if self.image_type == 'LT':
            cb.set_ticklabels(np.arange(0,35,4))
          else:
            cb.set_ticklabels(np.arange(0,45,5))
          cb.set_label('DU')

    fig0.legend()
    

    

  
  

  def classify_neighbors(self, image, regsX, regsY, polygons, values):
    #ca = np.zeros([len(polygons),len(polygons), len(values)], np.uint16)
    coordinatesList = list()

    # Ploting weights
    w_coords_x = list()
    w_coords_y = list()
    w_grays = list()

    # Normalization for gray values (Pollution)
    valuesNorm = (values - min(values)) / (max(values) - min(values))

    for i,value in enumerate(valuesNorm):
      # Normalization for X and Y
      coord_x = polygons[i].centroid.x / image.shape[1]
      coord_y = polygons[i].centroid.y / image.shape[0]
      gray_value = value * self.weight_gray_values

      ## To apply kmeans
      coordinatesList.append(np.array([coord_x,coord_y, gray_value]))
      
    coordinatesArray = np.asarray(coordinatesList)

    ## To plot weights
    for coord in coordinatesArray:
      w_coords_x.append(coord[0])
      w_coords_y.append(coord[1])
      w_grays.append(coord[2])

    fig_, ax0 = plt.subplots(1,1)
    number_regions = np.arange(len(coordinatesArray))

    w_legends = ["X","Y","Gray"]
    ax0.scatter(number_regions, w_coords_x, label=w_legends[0])
    ax0.scatter(number_regions, w_coords_y, label=w_legends[1])
    ax0.scatter(number_regions, w_grays, label=w_legends[2])
    ax0.set_title("Weights comparison")
    ax0.set_xlabel("Number of Regions")
    ax0.set_ylabel("Weight")
    hand, labl = ax0.get_legend_handles_labels()
    plt.legend()

    # TESTING KMEANS
    wcss = list()
    for i in range(1,50):
      kmeanstest = KMeans(n_clusters=i, random_state=0).fit(coordinatesArray)
      wcss.append(kmeanstest.inertia_)
      
    fig0, ax = plt.subplots(1,1)
    ax.scatter(self.N_CLUSTERS,wcss[self.N_CLUSTERS], c='red', label="Selected cluster")
    ax.plot( np.arange(len(wcss)) , wcss)
    ax.set_title("Optimal number of clusters")
    ax.set_xlabel("Number of clusters (k)")
    ax.set_ylabel("Inertia")
    fig0.legend()

    clustering = KMeans(n_clusters=self.N_CLUSTERS, max_iter=300).fit(coordinatesArray)

    x_range = [100, 150, 10]
    y_range = [20, 48, 5]

    rgsX2 = list()
    rgsY2 = list()

    for reg in regsX:
      line = list()
      for i in reg:
        line.append((i / (image.shape[1] / 50)) + 100)
      rgsX2.append(line)

    for reg in regsY:
      line = list()
      for i in reg:
        line.append(((image.shape[0] - i) / (image.shape[0] / 28)) + 20)
      rgsY2.append(line)

    fig, ax1 = plt.subplots(1,1)
    m=Basemap(llcrnrlon=100.,llcrnrlat=20.,urcrnrlon=150.,urcrnrlat=48.,resolution='i')
    m.drawcoastlines()
    m.drawmapboundary()
    m.drawmeridians(np.r_[100:151:10], labels=[0,0,0,1], color='grey',fontsize=8,linewidth=0)
    m.drawparallels(np.r_[20:48:5], labels=[1,0,0,0], color='grey',fontsize=8,linewidth=0)
    
    #print("labels", clustering.labels_)
    #print("center", clustering.cluster_centers_)

    # hls
    # Greys
    colors = sns.color_palette("hls", max(clustering.labels_) + 1)

    cmap = matplotlib.colors.ListedColormap(colors)
    norm = matplotlib.colors.BoundaryNorm(np.arange(max(clustering.labels_) + 1) - 0.5, cmap.N)
 
    for i,label in enumerate(clustering.labels_):
      ax1.scatter(rgsX2[i],rgsY2[i], marker='.', color=cmap(norm(label)) ) 
      ax1.set_xlim(*x_range)
      ax1.set_ylim(*y_range)
      ax1.set_title('CLUSTERS - IASI ' + self.image_type + " - " + str(self.day) +"/"+ str(self.month) +"/"+ str(self.year) + " - # Clusters: " + str(self.N_CLUSTERS) )

    sm = matplotlib.cm.ScalarMappable(cmap=cmap, norm=norm)
    cbar_ax = fig.add_axes([0.09, 0.06, 0.84, 0.02])
    cb = fig.colorbar(sm,cax=cbar_ax,orientation='horizontal')
    cb.set_ticklabels(np.arange(1,self.N_CLUSTERS))
    cb.set_ticks(np.arange(self.N_CLUSTERS), update_ticks=True)
    cb.set_label('Clusters')

    return clustering.labels_ , clustering.cluster_centers_




    
  def classify_regions(self, image, polygons):
    image = cv2.normalize(image, np.ones((image.shape[0], image.shape[0])) , self.vmin, self.vmax, cv2.NORM_MINMAX )

    temp_polygons = polygons.copy()
    first_poly = temp_polygons[0]

    for i,poly in enumerate(temp_polygons[:]): 
      if poly is None:
        continue 

      #for j,ut in enumerate(ut_polys[:]):
      if first_poly.intersects(poly):
        percentage = (first_poly.intersection(poly).area/first_poly.area) * 100

        if percentage > 85:
          value_poly_1 =  self.get_region_value(image, first_poly)
          value_poly_n =  self.get_region_value(image, poly)
          if np.abs(value_poly_1 - value_poly_n) < 5:
            temp_polygons[i] = None

    return temp_polygons



  def classify_all_regions(self, image, polygons):
    image = cv2.normalize(image, np.ones((image.shape[0], image.shape[0])) , self.vmin, self.vmax, cv2.NORM_MINMAX )
    
    temp_polygons = polygons.copy()
    #first_poly = temp_polygons[0]

    for i, poly in enumerate(temp_polygons[:]): 
      if poly is None:
        continue 
      
      if i == 0:
        first_poly = temp_polygons[0]
      #else:
      #  first_poly = poly

      if first_poly.intersects(poly):
        percentage = (first_poly.intersection(poly).area / first_poly.area) * 100

        if percentage > 85:
          value_poly_1 =  self.get_region_value(image, first_poly)
          value_poly_n =  self.get_region_value(image, poly)

          if np.abs(value_poly_1 - value_poly_n) < 5:
            temp_polygons[i] = None

    return temp_polygons


  def get_region_value(self, image, polygon, isABox=False):
    """
    This function returns the mean pixel value from a given polygon
    """
    image = cv2.normalize(image, np.ones((image.shape[0], image.shape[0])) , self.vmin, self.vmax, cv2.NORM_MINMAX )

    if isABox:
      minx, miny, maxx, maxy = polygon
    else:
      minx, miny, maxx, maxy = polygon.bounds #Boite englobante

    pixel_steps_x = image.shape[1] * self.degree / self.colgrid.shape[1]
    pixel_steps_y = image.shape[0] * self.degree / self.colgrid.shape[0]

    longs = np.arange(minx, maxx, pixel_steps_x)
    lats = np.arange(miny, maxy, pixel_steps_y)

    set_of_coordinates = list()
    for lon in longs:
      for lat in lats:
        if np.isnan(lat):
          print("lat is nan")
        if np.isnan(lon):
          print("lon is nan")

        if image[int(lat), int(lon)] > 0:
          set_of_coordinates.append(image[int(lat), int(lon)])

    value_pixel = np.mean(set_of_coordinates)

    if np.isnan(value_pixel):
      value_pixel = 1.
    
    return value_pixel


  def export_mser_regions (self,image,regsX,regsY,values,filename="regions-mser.png",default_color="Greys_r"):
    x_range = [0, image.shape[1]]
    y_range = [0, image.shape[0]]

    fig, ax = plt.subplots(1,1, figsize=(11,8), facecolor=(0, 0, 0))
    

    if self.image_type == 'LT':
      max_color_value = 35
    else:
      max_color_value = 45
    
    colors = sns.color_palette(default_color, max_color_value + 1)
    cmap = matplotlib.colors.ListedColormap(colors)
    norm = matplotlib.colors.BoundaryNorm(np.arange(max_color_value + 1) - 0.5, cmap.N)

    for i,val in enumerate(values):
      ax.scatter(regsX[i], regsY[i], marker='.', color=cmap(norm(int(val))) )
      ax.set_xlim(*x_range)
      ax.set_ylim(*y_range)
      ax.invert_yaxis()
      ax.axis('off')

    matplotlib.cm.ScalarMappable(cmap=cmap, norm=norm)
    fig.savefig(filename, bbox_inches='tight', pad_inches=0,transparent=True)
    plt.close(fig)

    return filename



  def plot_mser_final_regions (self, image, regsX, regsY, values):

    x_range = [100, 150, 10]
    y_range = [20, 48, 5]

    rgsX2 = list()
    rgsY2 = list()

    for reg in regsX:
      line = list()
      for i in reg:
        line.append((i / (image.shape[1] / 50)) + 100)
      rgsX2.append(line)

    for reg in regsY:
      line = list()
      for i in reg:
        line.append(((image.shape[0] - i) / (image.shape[0] / 28)) + 20)
      rgsY2.append(line)

    fig, ax = plt.subplots(1,1)
    m=Basemap(llcrnrlon=100.,llcrnrlat=20.,urcrnrlon=150.,urcrnrlat=48.,resolution='i')
    m.drawcoastlines()
    m.drawmapboundary()
    m.drawmeridians(np.r_[100:151:10], labels=[0,0,0,1], color='grey',fontsize=8,linewidth=0)
    m.drawparallels(np.r_[20:48:5], labels=[1,0,0,0], color='grey',fontsize=8,linewidth=0)

    if self.image_type == 'LT':
      max_color_value = 35
    else:
      max_color_value = 45
    
    colors = sns.color_palette("YlOrBr", max_color_value + 1)
    cmap = matplotlib.colors.ListedColormap(colors)
    norm = matplotlib.colors.BoundaryNorm(np.arange(max_color_value + 1) - 0.5, cmap.N)

    for i,val in enumerate(values):
      ax.scatter(rgsX2[i], rgsY2[i], marker='.', color=cmap(norm(int(val))) )
      ax.set_xlim(*x_range)
      ax.set_ylim(*y_range)
      ax.set_title('REGIONS ' + str(len(values)) + ' - IASI ' + self.image_type + " - " + str(self.day) +"/"+ str(self.month) +"/"+ str(self.year))

    sm = matplotlib.cm.ScalarMappable(cmap=cmap, norm=norm)
    cbar_ax = fig.add_axes([0.09, 0.06, 0.84, 0.02])
    cb = fig.colorbar(sm,cax=cbar_ax,orientation='horizontal')

    if self.image_type == 'LT':
      cb.set_ticklabels(np.arange(0,35,4))
    else:
      cb.set_ticklabels(np.arange(0,45,5))

    cb.set_label('DU')


  def plot_mser_regions_3d(self, regsX, regsY, values, labels):
    
    f3d = plt.figure(figsize=(14, 9))
    ax2 = plt.axes(projection ='3d')

    #colors = np.array(["yellow","blue","red","green","magenta","cyan","gray"])
    #colors = {0:"yellow", 1:"blue", 2:"red", 3: "green", 4: "magenta", 5: "cyan", 6:"gray"}
    #print("values", values)
    #print("labels", clustering.labels_)
    #print("center", clustering.cluster_centers_)
    
    for i,label in enumerate(labels):

      if label == 0:
        color = "red"
      elif label == 1:
        color = "yellow"
      elif label == 2:
        color = "green"
      elif label == 3:
        color = "magenta"
      elif label == 4:
        color = "cyan"
      elif label == 5:
        color = "gray"
      elif label == 6:
        color = "olive"
      else:
        color = "black"

      ax2.scatter(regsX[i], regsY[i], values[i], marker='.', c=color) # c=colors[clustering.labels_]       #,label='Region ' + str(i))
      ax2.set_title('IASI ' + self.image_type + " - " + str(self.day) +"/"+ str(self.month) +"/"+ str(self.year))
      



  def show_image(self, image):
    fig, ax = plt.subplots(1,1, figsize=(11,8))
    ax.imshow(image, cmap='gray')

  def plot_original_image(self):

    if self.image_type == 'LT':
      vmax = 35
      vmin = 3
    else:
      vmax = 45
      vmin = 5

    fig, ax1 = plt.subplots(1,1)
    
    m=Basemap(llcrnrlon=100.,llcrnrlat=20.,urcrnrlon=150.,urcrnrlat=48.,resolution='i')
    m.drawcoastlines()
    m.drawmapboundary()
    m.drawmeridians(np.r_[100:151:10], labels=[0,0,0,1], color='grey',fontsize=8,linewidth=0)
    m.drawparallels(np.r_[20:48:5], labels=[1,0,0,0], color='grey',fontsize=8,linewidth=0)

    divider = make_axes_locatable(ax1)
    cax = divider.append_axes('right', size='1%', pad=0.05)
    cs = ax1.pcolormesh(self.v_x, self.v_y, self.colgrid1, shading='nearest',cmap='jet', vmin=vmin, vmax=vmax)
    ax1.set_title('IASI ' + self.image_type + " - " + str(self.day) +"/"+ str(self.month) +"/"+ str(self.year))
    fig.colorbar(cs,cax=cax)
    

  ###############################################################
  ###             REMOVE TEMP FILES
  ###############################################################

  def remove_temporal_files(self):
    try:
      os.remove(self.image_name)
      #Raising your own errors
      raise ErrorType("Deleting")
    except ErrorType as e:
      print("Error deleting the file -> ", self.image_name)

imageLT = SplitImageLevels()

imageLT.set_year(2008)
imageLT.set_month(5)
imageLT.set_day(6)
imageLT.set_image_type("LT")
imageLT.set_image_name("levels")
imageLT.set_weight_gray_values(1)
imageLT.set_cluster_value(30)
imageLT.set_pixel_size(0.25,.125)

imageLT.get_image_by_leves()

imageLT.plot_original_image()

# imageLT.get_image_name()
bgr , gray = imageLT.load_image_from_files(imageLT.get_image_name())
#imageLT.process_set_images(gray,bgr)
#imageLT.remove_temporal_files()
#imageLT.plot_original_image()

image, foreground, background = imageLT.filter_image(gray)

kernel = np.ones((3,3),np.uint8)
foreground = cv2.dilate(foreground,kernel,iterations = 3)
image1 = cv2.bitwise_and(image,image, mask=foreground)
image2 = cv2.bitwise_and(image,image, mask=background)

myimage = cv2.cvtColor(image1, cv2.COLOR_GRAY2RGB)
myimage = cv2.bitwise_and(myimage,myimage, mask=foreground)
#t_i = cv2.normalize(image1, None, 0, 255, cv2.NORM_MINMAX )
t_i = ma.masked_values(image1, 0.)
#print(t_i[~t_i.mask])
#mymask = t_i.mask
#image3 = cv2.bitwise_and(image, image, mask=mymask)

print(t_i.max(), t_i.min())

fig, (ax0, ax1) = plt.subplots(1,2, figsize=(11,8))
ax0.imshow(myimage)
ax1.imshow(foreground)
#fig.title('Morpho Operations - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year))

#ax1.imshow(background, cmap="gray")
#ax2.imshow(image2)
#ax3.imshow(foreground, cmap="gray")

fig3, ax3 = plt.subplots(1,1)
#ax3.hist(t_i.ravel(), bins=256, range=(0.0, 1.0), fc='k', ec='k')
ax3.hist(t_i[~t_i.mask],256,[0,256], fc='k', ec='k')
#ax3.hist(image1.ravel(),254,[1,256], fc='k', ec='k')
fig3.show()

"""
delta	          it compares (sizei−sizei−delta)/sizei−delta
min_area	      prune the area which smaller than minArea
max_area	      prune the area which bigger than maxArea
max_variation	  prune the area have similar size to its children
min_diversity	  for color image, trace back to cut off mser with diversity less than min_diversity
max_evolution	  for color image, the evolution steps
area_threshold	for color image, the area threshold to cause re-initialize
min_margin	    for color image, ignore too small margin
edge_blur_size	for color image, the aperture size for edge blur
"""

mser = cv2.MSER_create( 1, # delta 
                       500, # min_area
                       34400, #max_area 
                       4., # max_variation 
                       .3, # min_diversity 
                       10000, # max_evolution 
                       1.04, # area_threshold 
                       0.004, # min_margin
                       5) # edge_blur_size

# (1, 100, 20000, .25, 1., 1000, 1.001, 0.003, 5)
regions, bboxes = mser.detectRegions(myimage)
regions = sorted(regions, key=cv2.contourArea, reverse=True)

def sort_boxes_by_area(box):
  x, y, w, h = box
  area = w * h
  return area

bboxes = sorted(bboxes, key=sort_boxes_by_area, reverse=True)

#regions, bboxes = imageLT.get_mser_regions(image1, 100, 30000)
#print(image1.shape)
print(len(regions))

img_mser = cv2.cvtColor(image1, cv2.COLOR_GRAY2RGB)

for p in regions[:]:
  for k in p:
    cv2.circle(img_mser, (k[0],k[1]), radius=0, color=(0, 0, 255), thickness=-1)
plt.imshow(img_mser)

img_mser = cv2.cvtColor(image1, cv2.COLOR_GRAY2RGB)

for p in regions[4:5]:
  for k in p:
    cv2.circle(img_mser, (k[0],k[1]), radius=0, color=(0, 0, 255), thickness=-1, lineType=cv2.FILLED)
plt.imshow(img_mser)

kernel = np.ones((6,6), np.uint8)
background  = cv2.morphologyEx(background, cv2.MORPH_DILATE, kernel)
regx, regy, regs, polys, lines, values = imageLT.set_mser_regions(t_i, background, regions[:])
imageLT.plot_mser_final_regions(t_i, regx, regy, values)

len(regions)

fig, ax = plt.subplots(1,1)
xx_range = [0, image.shape[1]]
yy_range = [0, image.shape[0]]

for j,poly in enumerate(polys[:]):
  xxx,yyy = poly.exterior.xy

  ax.plot(xxx,yyy)
  ax.set_xlim(*xx_range)
  ax.set_ylim(*yy_range)
  ax.invert_yaxis()

# Creation of Carte de labels

#x_x = regx.copy()
#y_y = regy.copy()
#v_gris = values.copy()
regs_temp = regions.copy()
bbox_temp = bboxes.copy()

#fig, ax = plt.subplots(1,1)
projected = np.zeros(image.shape, np.uint16)

from skimage.morphology import square


# font
font = cv2.FONT_HERSHEY_SIMPLEX
# fontScale
fontScale = .5
# Blue color in BGR
color = (255, 0, 0)
# Line thickness of 2 px
thickness = 1


N_REGS_S = 1
N_REGS = len(regions)
connected_components = list()

current = 1
for i,r in enumerate(regs_temp[:N_REGS]):
  counter = (i + 1)
  
  counter_has_summed = False
  cc_has_summed = False

  for j,k in enumerate(r):
    if projected[k[1]][k[0]] != 0:
      ## search intersection
      if counter_has_summed is False:
        counter = counter + 1 #int(projected[k[1]][k[0]])
        connected_components.append(counter)
        counter_has_summed = True

      #if k[0] % 3 == 0 and k[1] % 2 == 0 and k[0] % 2 == 0 and k[1] % 3 == 0 and k[0] % 5 and k[0] % 7 and k[1] % 7 and k[0] % 11 and k[0] % 13:
      #  cv2.putText(projected, str(counter), (k[0],k[1]), font, fontScale, 150, thickness, cv2.LINE_AA)
      cv2.circle(projected, (k[0],k[1]), radius=1, color=(counter), thickness=-1, lineType=cv2.FILLED)
    else:
      if cc_has_summed is False:
        connected_components.append(counter)
        cc_has_summed = True
      #if k[0] % 3 == 0 and k[1] % 2 == 0 and k[0] % 2 == 0 and k[1] % 3 == 0 and k[0] % 5 and k[0] % 7 and k[1] % 7 and k[0] % 11 and k[0] % 13:
      #  cv2.putText(projected, str(counter), (k[0],k[1]), font, fontScale, 50, thickness, cv2.LINE_AA)
      cv2.circle(projected, (k[0],k[1]), radius=1, color=(counter), thickness=-1, lineType=cv2.FILLED)
    
    #if cc_has_summed is False:
    #  connected_components.append(counter)
    #  cc_has_summed = True

kernel = np.ones((3,3),np.uint8)
projected = cv2.morphologyEx(projected, cv2.MORPH_CLOSE, kernel, iterations = 2)

print(counter)

projected1 = cv2.cvtColor(projected, cv2.COLOR_GRAY2BGR)

for box in bbox_temp[:N_REGS]:
  x, y, w, h = box
  cv2.rectangle(projected1, (x, y), (x + w, y + h), (0, 0, 255), 2)


# Using cv2.putText() method
for i,r in enumerate(regs_temp[:N_REGS]):
  cv2.putText(projected1, str(i+1), (r[0][0] + 10, r[0][1]), font, 1, color, thickness, cv2.LINE_AA)

fig, (ax1,ax2) = plt.subplots(1,2, figsize=(21,15))
ax1.imshow(projected, cmap="gray")
ax2.imshow(projected1)

pro = projected.copy()
pro = ma.masked_values(pro, 0.)
plt.imshow(pro)

f2,ax2 = plt.subplots(1,1)
ax2.hist(pro.ravel(),254,[1,N_REGS]);
f2.legend()
f2.show()

print(N_REGS)

# SI YO LE DIGO DEME LOS PIXELES DE LA REGION 20
REGION_TO_SEARCH = 70
tmp = np.zeros(projected.shape, np.uint16)
tmp = np.where(projected == REGION_TO_SEARCH,1,tmp)
plt.imshow(tmp, cmap="gray")

labels_partition, num = measure.label(pro, return_num=True, background=0.) 
#s = generate_binary_structure(2,2)
#_labels = ndimage.label(black_image, structure=s)
#labels_partition = _labels[0]
#num = _labels[1]

centers = ndimage.measurements.center_of_mass(pro, labels_partition, np.arange(1,num) )

print(len(centers))

fig, (ax1,ax2) = plt.subplots(1,2, figsize=(11,8))

for i,c in enumerate(centers):
  #if i == 100:
  ax1.scatter(c[1],c[0], c="red")
ax1.imshow(projected, cmap="gray")
ax2.imshow(labels_partition)

#all_labels = measure.label(bitmap)
  # return centroids
rescale=1.0
centroids = list()
areas_partition = list()
boxes_partition = list()
grays_values = list()
min_width=2
min_height=3

dani = 0

for region in measure.regionprops(label_image=labels_partition):
  x_min = region.bbox[1]
  x_max = region.bbox[3]
  y_min = region.bbox[0]
  y_max = region.bbox[2]

  if (x_max - x_min) > min_width and y_max - y_min > min_height:
    #boxes_partition.append(BoundingBox2D(x_min, x_max, y_min, y_max))
    #minx, miny, maxx, maxy
    boxes_partition.append(np.array([x_min,y_min,x_max,y_max]))
    cx, cy = map(lambda p: int(p*rescale), (region.centroid[0], region.centroid[1]))
    centroids.append((cx, cy))
    areas_partition.append(region.area)
    grays_values.append(imageLT.get_region_value(t_i,np.array([x_min,y_min,x_max,y_max]),True)) # Gray values for the regions partitions

print(len(centroids), len(areas_partition), len(boxes_partition), len(grays_values))

drawing = cv2.cvtColor(projected, cv2.COLOR_GRAY2BGR)

for i in range(len(centroids)):
    color = (random.randint(0,256), random.randint(0,256), random.randint(0,256))
    # ID: str(i+1)
    # Area: str(areas_partition[i])
    # DU: str(int(imageLT.get_region_value(t_i,boxes_partition[i],True)))
    cv2.putText(drawing, str(i+1), (int(centroids[i][1]), int(centroids[i][0])), font, .5, color, thickness, cv2.LINE_AA)
    cv2.circle(drawing, (int(centroids[i][1]), int(centroids[i][0])), 3, color, -1)

fig, ax = plt.subplots(1,1, figsize=(15,10))
ax.imshow(drawing)

REGION_TO_SEARCH = 51
tmp = np.zeros(image.shape, np.uint16)
tmp = np.where(labels_partition == REGION_TO_SEARCH,1,tmp)
plt.imshow(tmp, cmap="gray")





"""
components = [1..8]
for val in components:
"""

## CODIGO PARA CREAR PARTICION DE REGIONES COMO POLIGONOS
## PRIMERO ENCONTRAR BORDES
## LUEGO REGIONES

N_CLUSTERS = 5
WEIGHT = 5
im_regs = projected.copy()

image_norm = list()
weights_list = list()

## CREATE ARRAY BEFORE NORMALIZATION
for gray in grays_values:
  tmp_w = WEIGHT
  if gray >= np.mean(grays_values) and WEIGHT > 1:
    tmp_w = WEIGHT * 2
  else:
    tmp_w = WEIGHT / 2
  weights_list.append(gray * tmp_w)

gray_values_norm = (grays_values - min(grays_values)) / (max(grays_values) - min(grays_values))

for i,centroid in enumerate(centroids[:]):
  x = centroid[0] / im_regs.shape[0]
  y = centroid[1] / im_regs.shape[1]
  z = gray_values_norm[i]
  image_norm.append(np.array([x,y,z]))

image_norm_array = np.asarray(image_norm)
#image_norm_array = np.float32(image_norm_array)

weights = np.asarray(weights_list)

#plt.plot(image_norm)
#plt.scatter(np.arange(len(gray_values_norm)),gray_values_norm,c="red")
#plt.plot(np.arange(len(gray_values_norm)),np.full(len(gray_values_norm), 30),"--", c="green")


fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

for i in range(len(image_norm_array)):
  ax.scatter(image_norm_array[i,0],image_norm_array[i,1],image_norm_array[i,2], label="cluster " + str(i+1))

#ax.scatter(cluster_centers[:,0],cluster_centers[:,1],cluster_centers[:,2],s=200,label="centroid-"+str(i))
#plt.title("CLUSTERING W: " + str(WEIGHT) + " - IASI " + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year)) 
#ax.set_xlabel('Centre de gravité X')
#ax.set_ylabel('Centre de gravité Y')
#ax.set_zlabel('DU - normalized [0-1]')
#fig.legend()
fig.show()

plt.plot(weights)

# TESTING KMEANS
wcss = list()
# int((len(centers) / 5))
print("finding best cluster...")
for i in range(1,40):
  #print("kmeans for cluster #",i)
  kmeanstest = KMeans(n_clusters=i, random_state=0, max_iter=500).fit(image_norm_array, sample_weight=weights)
  wcss.append(kmeanstest.inertia_)

fig0, ax = plt.subplots(1,1)
ax.scatter(N_CLUSTERS,wcss[N_CLUSTERS], c='red', label="Selected cluster")
ax.plot( np.arange(len(wcss)) , wcss)
ax.set_title("Optimal number of clusters")
ax.set_xlabel("Number of clusters (k)")
ax.set_ylabel("Inertia")
fig0.legend()

print("clustering...")

clustering = KMeans(n_clusters=N_CLUSTERS,random_state=0, init='k-means++')
cluster_labels = clustering.fit_predict(image_norm_array, sample_weight=weights)
cluster_centers = clustering.cluster_centers_

#labels=tuned_clustering.fit_predict(X)
# x and y  coordinates of all clusters
# Centroids of clusters
#tuned_clustering.cluster_centers_[:]

print("plotting...")

cluster_labels1 = cluster_labels.copy()
cluster_labels1 += 1

fig, ax = plt.subplots(1,1)
tmp = np.zeros(im_regs.shape, np.uint8)
for i,lbl in enumerate(cluster_labels1[:]):
  tmp = np.where(labels_partition == (i+1), lbl, tmp)
  ax.imshow(tmp,cmap="gray")

print(cluster_centers.shape, max(cluster_labels), len(cluster_labels))

# visualizing the clusters

X = image_norm_array.copy()

#for i in range(max(cluster_labels)):
#  plt.scatter(X[cluster_labels==i,0],X[cluster_labels==i,1],label="cluster " + str(i+1))
#plt.scatter(cluster_centers[:,0],cluster_centers[:,1],s=200,c="black",label="centroid")
#plt.title("Clusters of regions")
#plt.xlabel("Centre de gravité X")
#plt.ylabel("Centre de gravité Y")
#plt.legend()
#plt.show()


fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

for i in range(max(cluster_labels) + 1):
  ax.scatter(X[cluster_labels==i,0],X[cluster_labels==i,1],X[cluster_labels==i,2], label="cluster " + str(i+1))
#for i, cluster in enumerate(cluster_centers):
#  ax.scatter(cluster[0],cluster[1],cluster[2],s=200,label="centroid-"+str(i))
ax.scatter(cluster_centers[:,0],cluster_centers[:,1],cluster_centers[:,2],s=200,c="black",label="centroid-"+str(i))
plt.title("CLUSTERING W: " + str(WEIGHT) + " - IASI " + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year)) 
ax.set_xlabel('Centre de gravité X')
ax.set_ylabel('Centre de gravité Y')
ax.set_zlabel('DU - normalized [0-1]')
fig.legend()
fig.show()

for i in range(max(cluster_labels) + 1 ):
  plt.scatter(X[cluster_labels==i,0],X[cluster_labels==i,1],label="cluster " + str(i+1))
plt.scatter(cluster_centers[:,0],cluster_centers[:,1],s=200,c="black",label="centroid")
plt.title("CLUSTERING W: " + str(WEIGHT) + " - IASI " + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year))
plt.xlabel("Centre de gravité X")
plt.ylabel("Centre de gravité Y")
#plt.legend()
plt.show()

from sklearn import metrics
metrics.silhouette_score(X, cluster_labels,metric='euclidean')

# visualizing Silhouette coefficient
for n_clusters in range(2,15):
 # Create a subplot with 1 row and 2 columns
 fig, (ax1, ax2) = plt.subplots(1, 2)
 fig.set_size_inches(18, 7)
# The 1st subplot is the silhouette plot
 # The silhouette coefficient can range from -1, 1 but in this example all
 # lie within [-0.1, 1]
 ax1.set_xlim([-0.1, 1])
 # The (n_clusters+1)*10 is for inserting blank space between silhouette
 # plots of individual clusters, to demarcate them clearly.
 ax1.set_ylim([0, len(X) + (n_clusters + 1) * 10])
# Initialize the clusterer with n_clusters value and a random generator
 # seed of 10 for reproducibility.
 clusterer = KMeans(n_clusters=n_clusters, random_state=10)
 cluster_labels = clusterer.fit_predict(X, sample_weight=weights)
# The silhouette_score gives the average value for all the samples.
 # This gives a perspective into the density and separation of the formed
 # clusters
 silhouette_avg = metrics.silhouette_score(X, cluster_labels)
 print("For n_clusters =", n_clusters, "The average silhouette_score is :", silhouette_avg)
# Compute the silhouette scores for each sample
 sample_silhouette_values = metrics.silhouette_samples(X, cluster_labels)
 y_lower = 10
 
 for i in range(n_clusters):
   ith_cluster_silhouette_values = sample_silhouette_values[cluster_labels == i]
   ith_cluster_silhouette_values.sort()
   
   size_cluster_i = ith_cluster_silhouette_values.shape[0]
   y_upper = y_lower + size_cluster_i
   #color = cm.nipy_spectral(float(i) / n_clusters) 
   ax1.fill_betweenx(np.arange(y_lower, y_upper), 0, ith_cluster_silhouette_values,alpha=0.7)
   
   ax1.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))
   
   y_lower = y_upper + 10 # 10 for the 0 samples
   ax1.set_title("The silhouette plot for the various clusters.")
   ax1.set_xlabel("The silhouette coefficient values")
   ax1.set_ylabel("Cluster label")
   
   ax1.axvline(x=silhouette_avg, color="red", linestyle="--")
   ax1.set_yticks([]) # Clear the yaxis labels / ticks
   ax1.set_xticks([-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1])
   
   #colors = cm.nipy_spectral(cluster_labels.astype(float) / n_clusters)
   ax2.scatter(X[:, 0], X[:, 1], marker=".", s=30, lw=0, alpha=0.7, edgecolor="k")
   
   centers = clusterer.cluster_centers_
   ax2.scatter(centers[:, 0], centers[:, 1], marker="o",c="white", alpha=1, s=200, edgecolor="k")
   
   for i, c in enumerate(centers):
     ax2.scatter(c[0], c[1], marker="$%d$" % i, alpha=1,s=50, edgecolor="k")
     ax2.set_title("The visualization of the clustered data.")
     ax2.set_xlabel("Feature space for the 1st feature")
     ax2.set_ylabel("Feature space for the 2nd feature")
     plt.suptitle(("Silhouette analysis for KMeans clustering on sample data with n_clusters = %d" % n_clusters), fontsize=14, fontweight="bold")
plt.show()

fig, ax = plt.subplots(1,1)

im_clusters = np.zeros(im_regs.shape, np.uint8)

for i,lbl in enumerate(cluster_labels[:]):
  im_clusters = np.where(labels_partition == (i + 1), lbl, im_clusters)
  ax.imshow(im_clusters,cmap="gray")

# SI YO LE DIGO DEME LOS PIXELES DEL CLUSTER 3 

tmp = np.zeros(im_regs.shape, np.uint8)
tmp = np.where(im_clusters == 9,1, tmp)
plt.imshow(tmp)

max(cluster_labels)

# test moments
r_c = regions.copy()

# GET the moments
mu = [None]*len(r_c)
for i in range(len(r_c)):
  mu[i] = cv2.moments(r_c[i])


# Get the mass centers
mc = [None]*len(r_c)
for i in range(len(r_c)):
    # add 1e-5 to avoid division by zero
    mc[i] = (mu[i]['m10'] / (mu[i]['m00'] + 1e-5), mu[i]['m01'] / (mu[i]['m00'] + 1e-5))

print(mu)





directories = os.listdir( imageLT.get_DIR_TRAIN() )
 
# This would print all the files and directories
for file in directories:
  only_png_files = re.search(".jpg", file)
  if only_png_files is not None:
    only_same_day = re.search(str(imageLT.get_year())+"%02d"%imageLT.get_month()+"%02d"%imageLT.get_day(), file)
    if only_same_day is not None:
      only_image_type = re.search(imageLT.get_image_type(), file)
      if only_image_type is not None:
        img = io.imread(imageLT.get_DIR_TRAIN() + file)
        #img = cv2.cvtColor(img, cv2.COLOR_RGBA2RGB)
        img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
        img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        #img_gray = ma.masked_values(img_gray, 255.)
        img_gray = cv2.GaussianBlur(img_gray,(5,5),cv2.BORDER_DEFAULT)

        best_regions_c = list()
        worst_regions_c = list()

        all_true_positives_c = list()
        all_true_negatives_c = list()
        all_false_positives_c = list()
        all_false_negatives_c = list()
        all_accuracy_c = list()

        for i in range(1,max(cluster_labels) + 1):
          im_bin = img_gray.copy()
          
          im_orig = np.zeros(im_regs.shape, np.uint8)
          im_orig = np.where(im_clusters == i,1, im_orig)

          im_bin = cv2.normalize(im_bin, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
          im_orig = cv2.normalize(im_orig, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
          
          c_m_temp = confusion_matrix(im_bin.flatten(), im_orig.flatten())
          true_positives = c_m_temp[1][1]
          false_positives = c_m_temp[0][1]
          false_negatives = c_m_temp[1][0]
          true_negatives = c_m_temp[0][0]

          accuracy = accuracy_score(im_bin.flatten(),im_orig.flatten()) * 100
              
          #print("\n")
          total_pixels_blancs_ref = len(im_bin[im_bin == 1])
          total_pixels_blancs_test = len(im_orig[im_orig == 1])

          #im_test_ones = np.ones(im_bin.shape, np.uint8)
          #im_test_ones = np.where(im_bin == 1,0,im_test_ones)
          #im_test_ones = np.where(im_orig == 1,0,im_test_ones)
          #total_pixels_noirs = len(im_test_ones[im_test_ones == 1])

          #print("pixels: true_positives", true_positives)
          #print("pixels: false_positives",false_positives)
          #print("pixels: false_negatives",false_negatives)
          #print("pixels: true_negatives",true_negatives)
          #print("total_pixels_blancs_ref", total_pixels_blancs_ref)
          #print("total_pixels_blancs_test", total_pixels_blancs_test)
          
          print("perc: true_positives", int(true_positives * 100 / total_pixels_blancs_test), "%")
          print("perc: false_positives", int(false_positives * 100 / total_pixels_blancs_test), "%")
          print("perc: false_negatives", int(false_negatives * 100 / total_pixels_blancs_ref), "%")
          #print("perc: true_negatives", int(true_negatives * 100 / total_pixels_noirs), "%")

          all_true_positives_c.append(true_positives * 100 / total_pixels_blancs_test)
          all_false_positives_c.append(false_positives * 100 / total_pixels_blancs_test)
          all_false_negatives_c.append(false_negatives * 100 / total_pixels_blancs_ref)
          #all_true_negatives.append(true_negatives * 100 / total_pixels_noirs)
          all_accuracy_c.append(accuracy)

          if int(true_positives * 100 / total_pixels_blancs_test) >= 30:
            best_regions_c.append(im_orig)
          else:
            worst_regions_c.append(im_orig)

          #error = np.sum(np.abs(im_orig - im_bin))

          # visualize the differences between the original image and the solution
          plt.figure()
          plt.title('Ground Truth and Regions - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year) )
          plt.imshow(np.dstack((np.int_(im_orig), im_bin, im_bin))*255)
          plt.show()

sensitivity_c = list()
for i,tp in enumerate(all_true_positives_c):
  sensitivity_c.append(tp / (tp + all_false_negatives_c[i]))

fig, ax = plt.subplots(1,1)
ax.plot( np.arange(len(all_true_positives_c)), all_true_positives_c, label="True Positives")
ax.plot( np.arange(len(all_false_positives_c)), all_false_positives_c, label="False Positives")
ax.plot( np.arange(len(all_false_negatives_c)), all_false_negatives_c, label="False Negatives")
ax.plot( np.arange(len(all_accuracy_c)), all_accuracy_c, "--", label="Accuracy")
#ax.plot( np.arange(len(sensitivity_c)), sensitivity_c, "--", label="Sensitivity")

ax.set_title('Confusion Matrix variation - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year))
ax.set_xlabel("Cluster index")
ax.set_ylabel("Confusion Matrix values %")
ax.legend()

fig, (axx, axx2) = plt.subplots(1,2)

black_image_best = np.zeros(best_regions_c[0].shape, np.uint8)
black_image_worst = np.zeros(worst_regions_c[0].shape, np.uint8)

for reg in best_regions_c[:]:
  tmp = ma.masked_values(reg, 0.)
  for i,x in enumerate(tmp[:]):
    for j,y in enumerate(x):
      if isinstance(y, np.uint8):
        black_image_best[i][j] = 1

for reg in worst_regions_c[:]:
  tmp = ma.masked_values(reg, 0.)
  for i,x in enumerate(tmp[:]):
    for j,y in enumerate(x):
      if isinstance(y, np.uint8):
        black_image_worst[i][j] = 1


axx.imshow(black_image_best, cmap="gray")
axx.set_title('Best regions - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year) )
axx2.imshow(black_image_worst, cmap="gray")
axx2.set_title('Worst regions - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year) )

## COMPARING TRUE POSITIVES WITH GRAY VALUES AND POSITION IN SPACE

all_t_p_c = all_true_positives_c.copy()
all_f_p_c = all_false_positives_c.copy()
all_t_n_c = all_true_negatives_c.copy()
all_f_n_c = all_false_negatives_c.copy()

rx_test = regx.copy()
ry_test = regy.copy()
val_test = values.copy()

gray_levels_true_positive_c = list() # List of the best gray levels based on the true positives
for i,tp in enumerate(all_t_p_c):
  #if tp > 0:
  gray_levels_true_positive_c.append(val_test[i])


plt.boxplot([gray_levels_true_positive_c])
plt.title('Dobson units related with the regions found - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year))
plt.xlabel("True Positives")
plt.ylabel('DU')
ticks = range(1,2)
labels_plot = list(["TP"])
plt.xticks(ticks,labels_plot)
plt.show()

## THIS IS FOR COMPARE MSER REGIONS WITH THE GROUND TRUTH

im_bin = img_gray.copy()
mser_regions = regions.copy()
from sklearn.metrics import accuracy_score 

true_list_new = list()
pred_list_new = list()

all_true_positives = list()
all_true_negatives = list()
all_false_positives = list()
all_false_negatives = list()

all_accuracy = list()

for ii,region in enumerate(mser_regions[:10]):
  try:
    img_mser = np.zeros(img_gray.shape, np.uint8)
    for k in region:
      cv2.circle(img_mser, (k[0],k[1]), radius=0, color=255, thickness=-1)
    im_orig = img_mser.copy()
    im_orig = cv2.normalize(im_orig, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
    im_bin = cv2.normalize(im_bin, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
    c_m_temp = confusion_matrix(im_bin.flatten(), im_orig.flatten())
    true_positives = c_m_temp[1][1]
    false_positives = c_m_temp[0][1]
    false_negatives = c_m_temp[1][0]
    true_negatives = c_m_temp[0][0]
    accuracy = accuracy_score(im_bin.flatten(),im_orig.flatten()) * 100
    total_pixels_blancs_test = len(im_orig[im_orig == 1])
    all_true_positives.append(int(true_positives * 100 / total_pixels_blancs_test))
    all_false_positives.append(int(false_positives * 100 / total_pixels_blancs_test))
    all_accuracy.append(accuracy)
    if int(true_positives * 100 / total_pixels_blancs_test) >= 30:
      best_regions.append(im_orig)
    else:
      worst_regions.append(im_orig)
  except:
    print("There was an error at region", ii)
  

fig, ax = plt.subplots(1,1)
#ax.plot( np.arange(len(all_true_positives)), all_true_positives, label="True Positives")
ax.plot( np.arange(len(all_false_positives)), all_false_positives, label="False Positives")
ax.plot( np.arange(len(all_accuracy)), all_accuracy, "--", label="Accuracy")
ax.legend()


  #true_list_new.append(im_bin)
  #pred_list_new.append(im_orig)

#true_list_new=np.array(true_list_new)
#pred_list_new=np.array(pred_list_new)

#true_list_new=true_list_new.flatten()
#pred_list_new=pred_list_new.flatten()

#c_m_mser = confusion_matrix(true_list_new, pred_list_new)
#a_s_mser = accuracy_score(true_list_new,pred_list_new) * 100

#print("Confusion Matrix: ", c_m_mser) 
#print("Accuracy : ", a_s_mser)

len(all_true_positives)

## COMPARING TRUE POSITIVES WITH GRAY VALUES AND POSITION IN SPACE

all_t_p = all_true_positives.copy()
all_f_p = all_false_positives.copy()

rx_test = regx.copy()
ry_test = regy.copy()
val_test = values.copy()
my_polys = polys.copy()

fig, ax = plt.subplots(1,1)
#fig1, ax1 = plt.subplots(1,1)
x_range = [0, image.shape[1]]
y_range = [0, image.shape[0]]

## FIG in 3D

#f3d = plt.figure(figsize=(14, 9))
#ax2 = plt.axes(projection ='3d')


# ax.imshow(np.dstack((np.int_(im_orig), im_bin, im_bin))*255)

gray_levels_true_positive = list() # List of the best gray levels based on the true positives
how_many_true_positive_regions = 0
for i,tp in enumerate(all_t_p):  
  if tp > 0:
    gray_levels_true_positive.append(val_test[i])
    how_many_true_positive_regions += 1
  ax.scatter(rx_test[i], ry_test[i], marker='.',cmap="gray")
  ax.set_xlim(*x_range)
  ax.set_ylim(*y_range)
  ax.set_title('TP MSER REGIONS - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year))
  ax.invert_yaxis()
    #ax.imshow(np.dstack((np.int_(im_orig), im_bin, im_bin))*255)

print("how_many_true_positive_regions", how_many_true_positive_regions, "of", len(val_test))

gray_leves_false_positive = list()

for i,fp in enumerate(all_f_p):
  #if fp < 100:
  gray_leves_false_positive.append(val_test[i])

plt.imshow(im_bin, cmap="gray")

plt.boxplot([gray_levels_true_positive])
plt.title('Dobson units related with the regions found - IASI ' + imageLT.image_type + " - " + str(imageLT.day) +"/"+ str(imageLT.month) +"/"+ str(imageLT.year))
plt.xlabel("True Positives")
plt.ylabel('DU')
ticks = range(1,2)
labels = list(["TP"])
plt.xticks(ticks,labels)
plt.show()















def setIterationForDay(day=1,typei="LT"):
  imageLT = SplitImageLevels()
  month=5

  imageLT.set_year(2008)
  imageLT.set_month(month)
  imageLT.set_day(day)
  imageLT.set_image_type(typei)
  imageLT.set_image_name("levels")
  imageLT.set_weight_gray_values(1)
  imageLT.set_cluster_value(30)
  imageLT.set_pixel_size(0.25,.125)
  imageLT.get_image_by_leves()
  bgr , gray = imageLT.load_image_from_files(imageLT.get_image_name())
  image, foreground, background = imageLT.filter_image(gray)
  kernel = np.ones((3,3),np.uint8)
  foreground = cv2.dilate(foreground,kernel,iterations = 3)
  image1 = cv2.bitwise_and(image,image, mask=foreground)
  image2 = cv2.bitwise_and(image,image, mask=background)
  myimage = cv2.cvtColor(image1, cv2.COLOR_GRAY2RGB)
  myimage = cv2.bitwise_and(myimage,myimage, mask=foreground)
  t_i = ma.masked_values(image1, 0.)
  mser = cv2.MSER_create( 1, # delta 
                        100, # min_area
                        34400, #max_area 
                        4., # max_variation 
                        .01, # min_diversity 
                        10000, # max_evolution 
                        1.04, # area_threshold 
                        0.003, # min_margin
                        5) # edge_blur_size

  # (1, 100, 20000, .25, 1., 1000, 1.001, 0.003, 5)
  regions, bboxes = mser.detectRegions(myimage)
  regions = sorted(regions, key=cv2.contourArea, reverse=True)
  regx, regy, polys, lines, values = imageLT.set_mser_regions(t_i, background, regions[:])
  
  export_original_d(day,typei)
  export_regions(day,typei)

def export_original_d(day=1,typei="LT"):
  month=5
  fig2, (ax2) = plt.subplots(1, 1, figsize = (11,8))
  ax2.pcolormesh(imageLT.v_x, imageLT.v_y, imageLT.colgrid1, shading='nearest',cmap='jet', vmin=imageLT.vmin, vmax=imageLT.vmax)
  ax2.axis('off')
  image_name = typei + '-color-' + str(2008) + '%02d'%month+'%02d'%day+'.png'
  fig2.savefig(DIR_TEST + "06-06/"+ image_name, bbox_inches='tight', pad_inches=0)
  plt.close(fig2)

def export_regions(day=1,typei="LT"):
  month=5
  x_range = [0, image.shape[1]]
  y_range = [0, image.shape[0]]

  fig, ax = plt.subplots(1,1, figsize=(11,8), facecolor=(0, 0, 0))

  if imageLT.image_type == 'LT':
    max_color_value = 35
  else:
    max_color_value = 45

  colors = sns.color_palette("YlOrBr_r", max_color_value + 1)
  cmap = matplotlib.colors.ListedColormap(colors)
  norm = matplotlib.colors.BoundaryNorm(np.arange(max_color_value + 1) - 0.5, cmap.N)

  for i,val in enumerate(values):
    ax.scatter(regx[i], regy[i], marker='.', color=cmap(norm(int(val))) )
    ax.set_xlim(*x_range)
    ax.set_ylim(*y_range)
    ax.invert_yaxis()
    ax.axis('off')

  matplotlib.cm.ScalarMappable(cmap=cmap, norm=norm)
  image_name = typei + '-reg-' + str(2008) + '%02d'%month+'%02d'%day+'.png'
  fig.savefig(DIR_TEST + "06-06/" + image_name, bbox_inches='tight', pad_inches=0,transparent=True)
  plt.close(fig)









