# -*- coding: utf-8 -*-
"""Diip - Images Satellites

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16SvclheI8YAlelhMFv49KGw0zHwfethE

# Import Libraries
"""

#!/bin/env python
import glob
import os
import numpy as np
import numpy.ma as ma
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
plt.rcParams.update({'figure.max_open_warning': 0})
import matplotlib.colors as mcolors
from scipy.interpolate import griddata
import torch
from mpl_toolkits.mplot3d import Axes3D
from PIL import Image
from skimage import measure, transform
from scipy.ndimage import label
from scipy.spatial import distance
from scipy import ndimage
from shapely.geometry import Point, LineString, Polygon, LinearRing, MultiPoint
from descartes import PolygonPatch
import tarfile
import string
import calendar

from google.colab import drive
drive.mount("/content/drive")

#!pip install opencv-python==3.4.2.16
#!pip install opencv-contrib-python==3.4.2.16

import cv2
from google.colab.patches import cv2_imshow
print(cv2.__version__)

!pip install pyMCR

!apt-get install libgeos-3.5.0
!apt-get install libgeos-dev
!pip install https://github.com/matplotlib/basemap/archive/master.zip
!pip install http://sourceforge.net/projects/matplotlib/files/matplotlib-toolkits/

from mpl_toolkits.basemap import Basemap,cm

!pip install netcdf4
import netCDF4

!ls

"""# Directory"""

DIR = '/content/drive/MyDrive/StageUParis/DATA/H2O/'
DIR_TEST = '/content/drive/MyDrive/StageUParis/Test/'
#DIR='/DATA/IASI/EXTERNAL/SUSTAINABLE/DUFOUR/IASIO3daily_PolEASIA/H2O/'

"""# Main Code

Données
- Lattitude
- Longitude
- Valeur
"""

def plotHistogram(img):
  color = ('b','g','r')
  plt.figure()
  for i,col in enumerate(color):
      histr = cv2.calcHist([img],[i],None,[256],[0,256])
      plt.plot(histr,color = col)
      plt.xlim([0,256])
  plt.show()

deg = .125
size1 = .0625

## LOOP
start = 1
end = 20

# Dates
day = 7
image_type="UT"
year=2008
month=5

## THRESH
global_regions = []
global_contours = []
global_mser = []
global_laplacian = []
global_thresh = 50
global_thresh_down = global_thresh - 5
global_thresh_condition = False

for i in range(start,end):
  if (i==0):
    continue

  print("Threshold", global_thresh)
  if global_thresh < 0:
    break

  degree = 0.625 # deg * i
  size = 0.3125 # (degree * size1) /  deg
  thres=(i-20)
  iteration=i
  image_name = DIR_TEST + image_type+"-mesh-"+str(year)+"%02d"%month+"%02d"%day+"-i-0"+str(i)+".png"
  # plot_sequence_images(degree = deg2, size = size2, thres=(i-20), iteration=i, image_type=image_type, day=day )

  lat_g = np.arange(20.,50.,degree)
  lon_g = np.arange(100.,150.,degree)

  #initialization
  colgrid = np.zeros([lat_g.shape[0],lon_g.shape[0]], np.uint8)

  for year in range(2008,2009):
    for month in range(5,6):
      ndays = calendar.mdays[month] + (month==2 and calendar.isleap(year))
      print(year,month,ndays)

      for dd in range (day,day+1):
        
        fname = DIR+'IASIdaily_'+str(year)+"%02d"%month+"%02d"%dd+'.nc'

        #read IASI data in nc archive
        if not(os.path.isfile(fname)):
          continue

        nc = netCDF4.Dataset(fname)
        flg = nc.variables['flag'][:]
        mask1 = (flg == 0)
        
        lat = nc.variables['lat'][mask1]
        lon = nc.variables['lon'][mask1]
        col = nc.variables[image_type][mask1]
        nc.close()

        print("Col",int(col.max() - 5))
        if global_thresh < int(col.max() - 5) and global_thresh_condition == False:
          global_thresh = int(col.max() -5)
          global_thresh_condition = True
      
        print('end read nc')
        mask2 = (np.isnan(col) == False) 

        # gridding the data
        for ilat in range(lat_g.shape[0]):
          for ilon in range(lon_g.shape[0]):
            # Grille régulier
            # 25 km
            # 0 25 degrée lattitude et longitude

            # Grille regulier of 0.125 degree
            maskgrid = (lat[:] >= (lat_g[ilat] - size)) & (lat[:] < (lat_g[ilat] + size)) & (lon[:] >= (lon_g[ilon] - size)) & (lon[:] < (lon_g[ilon] + size))
            
            # Defining invalid data
            mask = mask2 & maskgrid

            # Add a media filter for the grill regulier
            isMask = (len(col[mask]) != 0) & (col[mask] >= thres).all()

            if len(col[mask]) != 0:
              median = np.mean(col[mask])
              #if (median >= global_thresh_down and median <= global_thresh):
              if median >= global_thresh:
                colgrid[ilat,ilon] = median

        # We mark the values at colgrid as invalid because they are maybe false positives or bad sampling
        #colgrid = ma.masked_values(colgrid, 0.)

        v_x, v_y = np.meshgrid(lon_g, lat_g)
        gradx, grady = np.gradient(colgrid, edge_order=1)

        data = np.full((colgrid.shape[0], colgrid.shape[1]), colgrid, np.uint8)
        img_bgr = cv2.cvtColor(data, cv2.COLOR_GRAY2BGR)
        gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
        #gray = cv2.normalize(gray, np.ones((lon_g.shape[0], lat_g.shape[0])) , 0, 255, cv2.NORM_MINMAX )

        scale_percent = 100 #200 # percent of original size
        width = int(gray.shape[1] * scale_percent / 100)
        height = int(gray.shape[0] * scale_percent / 100)
        dim = (width, height)
        gray = cv2.resize(gray, dim, interpolation = cv2.INTER_AREA)

        kernel = np.ones((3,3),np.uint8)
        closing = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, kernel, iterations = 3)
        image_close = closing.copy()

        image_large_close = cv2.morphologyEx(closing, cv2.MORPH_CLOSE, np.ones((9,9),np.uint8), iterations = 3)
        image_holes = image_close.copy()

        # DILATE HOLES
        image_holes = np.where(image_holes == 0, 255, image_holes)
        image_holes = np.where(image_holes != 255, 0, image_holes)
        image_holes_dilate = cv2.morphologyEx(image_holes, cv2.MORPH_DILATE, np.ones((3,3),np.uint8), iterations = 2)
        image_holes_dilate_inv = cv2.bitwise_not(image_holes_dilate)
        
        gray = image_close.copy()
        global_regions.append(gray)

        ## Below code convert image gradient in both x and y direction
        image_laplacian = cv2.Laplacian(gray, cv2.CV_16U, ksize=3) 
        image_laplacian = np.uint8(np.absolute(image_laplacian))
        image_laplacian = cv2.bitwise_and(image_laplacian,image_laplacian,mask = image_holes_dilate_inv)

        global_laplacian.append(image_laplacian)
        ## Below code convert image gradient in x direction
        sobelx= cv2.Sobel(gray, 0, dx=1,dy=0)
        sobelx= np.uint8(np.absolute(sobelx))
        ## Below code convert image gradient in y direction
        sobely= cv2.Sobel(gray, 0, dx=0,dy=1)
        sobely = np.uint8(np.absolute(sobely))

        image_contour = image_laplacian.copy()
        edge = cv2.Canny(image_contour, colgrid.min(), colgrid.max())

        contours, h = cv2.findContours(edge, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        contours = sorted(contours, key=cv2.contourArea, reverse=True)

        for c in contours:
          hull = cv2.convexHull(c)
          cv2.drawContours(image_contour, [hull], 0, (255,255, 255), 1)

        global_contours.append(contours)

        #Create MSER object
        mser = cv2.MSER_create()
        image_mser = image_laplacian.copy()

        #detect regions in gray scale image
        regions, bboxes = mser.detectRegions(gray)

        global_mser.append(regions)

        hulls = [cv2.convexHull(p.reshape(-1, 1, 2)) for p in regions]
        isClosed = True
        # Blue color in BGR 
        color = (255, 0, 0) 
          
        # Line thickness of 2 px 
        thickness = 1

        cv2.polylines(image_mser, hulls,isClosed, color, thickness)
        #image_mser = cv2.bitwise_and(image_mser,image_mser,mask = image_holes_dilate_inv)

        _, labels, _, _ = cv2.connectedComponentsWithStats(image_laplacian, connectivity=8, ltype=cv2.CV_32S) 

        # Map component labels to hue val
        label_hue = np.uint8(170 * labels/np.max(labels))
        blank_ch = 255*np.ones_like(label_hue)
        labeled_img = cv2.merge([label_hue, blank_ch, blank_ch])

        # cvt to BGR for display
        labeled_img = cv2.cvtColor(labeled_img, cv2.COLOR_HSV2BGR)

        # set bg label to black
        labeled_img[label_hue==0] = 0

        fig, (ax0,ax1,ax2,ax3) = plt.subplots(1,4, figsize=(21,15))
        ax0.imshow(gray, cmap="gray")
        ax0.invert_yaxis()
        ax1.imshow(image_laplacian, cmap="gray")
        ax1.invert_yaxis()
        ax2.imshow(image_contour, cmap="gray")
        ax2.invert_yaxis()
        ax3.imshow(image_mser, cmap="gray")
        ax3.invert_yaxis()

  global_thresh -= 5
  global_thresh_down -= 5
  print('end month')

## PRE TREATMENT

treated_image = image_close.copy()
test3 = treated_image.copy()

background_image = treated_image.copy()
background_image = np.where(background_image == 0, 255, background_image)
background_image = np.where(background_image != 255, 0, background_image)
background_dilate = cv2.morphologyEx(background_image, cv2.MORPH_DILATE, np.ones((3,3),np.uint8), iterations = 3)

t_paint = cv2.inpaint(treated_image, background_dilate, 3, cv2.INPAINT_NS) # INPAINT_TELEA

f1, (ax1,ax2) = plt.subplots(1, 2, figsize=(21,15))
ax1.imshow(treated_image , cmap="gray")
ax1.invert_yaxis()
ax2.imshow(background_dilate , cmap="gray")
ax2.invert_yaxis()

### SHOWS THE LAPLACIAN AT DIFFERENT LEVELS

test_global_lap = global_laplacian.copy()

i = 0
for image in range(len(test_global_lap) - 1):
  print("i", i)
  if i == 0:
    image1 = test_global_lap[i]
  else:
    image1 = image3

  image2 = test_global_lap[i + 1]
  image3 = cv2.addWeighted(image1,1,image2,.7,0)

  final_laplacian = image3.copy()
  
  f, (ax1) = plt.subplots(1, 1, figsize = (11,8))
  ax1.imshow(final_laplacian, cmap="gray")
  ax1.invert_yaxis()
  #f.savefig(DIR_TEST + image_type + "/gradient/" + image_type + "_gradient_" + str(year) + "-" + str(month) + "-" + str(day) + "_deg_" + str(degree) + "_i_0" + str(i) + ".png", pad_inches=.01)
  i += 1

## CALCULATE THE BACKGROUND AT EACH LEVEL AND THE FINAL GRAY IMAGE

test_global_regs = global_regions.copy()

i = 0
for image in range(len(test_global_regs) - 1):
  if i == 0:
    image1 = test_global_regs[i]
  else:
    image1 = image3

  image2 = test_global_regs[i + 1]
  image3 = cv2.addWeighted(image1,1,image2,.7,0)

  combination_regions = image3.copy()
  current_region = test_global_regs[i]

  background_image = current_region.copy()
  background_image = np.where(background_image == 0, 255, background_image)
  background_image = np.where(background_image != 255, 0, background_image)

  f, (ax1) = plt.subplots(1, 1, figsize = (11,8))
  ax1.imshow(combination_regions, cmap="gray")
  ax1.invert_yaxis()

  # f.savefig(DIR_TEST + "/05-03/" + image_type + "/" + image_type + "_combination_" + str(year) + "-" + str(month) + "-" + str(day) + "_deg_" + str(degree) + "_i_0" + str(i) + ".png", pad_inches=.01)

  i += 1

#Create MSER object
mser1 = cv2.MSER_create()
image_background = background_image.copy() # background
image_pollution = combination_regions.copy() # foreground
mser1.setMaxArea(2500)

#mser1.setMaxArea(5000)

#detect regions in gray scale image
regions_pollution, bboxes4 = mser1.detectRegions(image_pollution)
regions_pollution = sorted(regions_pollution, key=cv2.contourArea, reverse=True)

regions_background, bboxes5 = mser1.detectRegions(image_background)
regions_background = sorted(regions_background, key=cv2.contourArea, reverse=True)

isClosed = True
## Blue color in BGR 
color = (255, 0, 0)
## Line thickness of 2 px 
thickness = -1

fig = plt.figure()

f3d = plt.figure(figsize=(11,8))
ax3d = plt.axes(projection='3d')

for c in regions_pollution:
  region = list()
  temp = np.zeros(image_pollution.shape, np.uint8)
  hull = cv2.convexHull(c)

  for h in hull:
    region.append(h[0].tolist())

  region.append(region[0])
  poly = Polygon(region)

  line = LineString(region)
  x, y = line.xy

  coord_x = int(line.centroid.x)
  coord_y = int(line.centroid.y)

  #plt.plot(x,y)
  ax = fig.add_subplot(111)
  ring_patch = PolygonPatch(poly)
  ax.add_patch(ring_patch)
  xrange = [0, image_pollution.shape[1]]
  yrange = [0, image_pollution.shape[0]]
  ax.set_xlim(*xrange)
  ax.set_ylim(*yrange)


  value_pixel = image_pollution[coord_y, coord_x]
  print("value", value_pixel)

  z = np.full(len(x),value_pixel)
  # Data for a three-dimensional line
  ax3d.plot3D(x, y, z, label="Gray value: " +str(value_pixel) )
  leg = ax3d.legend()

def jaccard_similarity(list1, list2):
    intersection = len(set(list1).intersection(list2))
    union = len(set(list1)) + len(set(list2)) - intersection

    return intersection / union

# Define region to compare

region1test = regions_background.copy()
region2test = regions_pollution.copy()

reg0 = list()
hull0 = cv2.convexHull(region1test[1])
for h in hull0:
  reg0.append(h[0].tolist())
reg0.append(reg0[0])
poly0 = Polygon(reg0)

fig0 = plt.figure()
ax0 = fig0.add_subplot(111)
ring_patch = PolygonPatch(poly0)
ax0.add_patch(ring_patch)
ax0.set_facecolor('gray')
xrange0 = [0, current_region.shape[1]]
yrange0 = [0, current_region.shape[0]]
ax0.set_xlim(*xrange0)
ax0.set_ylim(*yrange0)

print("INITIAL SIZE",len(region2test))

poligons = list()
fig = plt.figure()

for i,r in enumerate(region2test):
  reg1 = list()
  hull1 = cv2.convexHull(r)
  for h in hull1:
    reg1.append(h[0].tolist())
  reg1.append(reg1[0])
  poly1 = Polygon(reg1)

  ## If the regions are intersected -> remove it
  if poly0.intersects(poly1):
    poligons.append(poly1)
    ax1 = fig.add_subplot(111)
    ring_patch1 = PolygonPatch(poly1)
    ax1.add_patch(ring_patch1)
    xrange1 = [0, current_region.shape[1]]
    yrange1 = [0, current_region.shape[0]]
    ax1.set_xlim(*xrange1)
    ax1.set_ylim(*yrange1)

r_background = regions_background.copy()
r_pollution = regions_pollution.copy()

# Define region to compare iterativamente

global_polygon = list()

r_background = regions_background.copy()
r_pollution = regions_pollution.copy()

print("init -------",len(r_pollution))
new_reg_ca = list()
new_reg_ca2 = list()

#new_ca = r_pollution

for i,r0 in enumerate(r_pollution):
  if r0 is None:
    continue

  reg0 = list()
  hull0 = cv2.convexHull(r0)
  for h0 in hull0:
    reg0.append(h0[0].tolist())
  reg0.append(reg0[0])
  poly0 = Polygon(reg0)
  
  print("\n")
  print("Polygon...", i)

  for j, r1 in enumerate(r_background):
    reg1 = list()
    hull1 = cv2.convexHull(r1)
    for h in hull1:
      reg1.append(h[0].tolist())
    reg1.append(reg1[0])
    poly1 = Polygon(reg1)

    print("Sub-polugon...", j)

    if poly0.intersects(poly1) is True:
      print("deleting...",i,j)
      #new_ca[i] = None
      del r_pollution[i]
      #r_pollution.pop(i)
      #new_reg_ca.append(poly0)
      #new_reg_ca2.append(reg0)
      #print("deleted!",i)


#for k, ii in enumerate(new_ca):
#  if ii is None:
#    new_ca.pop(k)

print(type(new_ca), len(new_ca))
print("len r_pollution", len(r_pollution))

colgrid_value = colgrid.copy()

f, ax1 = plt.subplots(1, 1, figsize=(11,8))
i = 0
for r in r_pollution:
  reg0 = list()
  hull0 = cv2.convexHull(r)
  for h0 in hull0:
    reg0.append(h0[0].tolist())
  reg0.append(reg0[0])
  poly0 = Polygon(reg0)

  #print("------------------------------------------------------------")
  #print("shape", image_pollution.shape )
  coord_x = int(poly0.centroid.x)
  coord_y = int(poly0.centroid.y)
  #print(coord_x, coord_y )
  #print("Value colgrid", colgrid_value[coord_y,coord_x])
  #print("Value gray", image_pollution[coord_y, coord_x])
  #print("mean",image_pollution.mean(), colgrid.mean())

  if treated_image[coord_y, coord_x] > 0:
    #f, ax1 = plt.subplots(1, 1, figsize=(11,8))
    ring_patch = PolygonPatch(poly0)
    ax1.add_patch(ring_patch)
    xrange1 = [0, current_region.shape[1]]
    yrange1 = [0, current_region.shape[0]]
    ax1.set_xlim(*xrange1)
    ax1.set_ylim(*yrange1)
    #ax1.imshow(image_pollution, cmap="gray")
    #f.savefig(DIR_TEST + "/05-03/" + image_type + "/" + image_type + "_bluereg_" + str(year) + "-" + str(month) + "-" + str(day) + "_deg_" + str(degree) + "_i_0" + str(i) + ".png", pad_inches=.01)
    i += 10

f, ax = plt.subplots(1, 1, figsize=(11,8))

f3d = plt.figure(figsize=(11,8))
ax3d = plt.axes(projection='3d')

for r in r_pollution:
  if r is None:
    continue

  reg0 = list()
  hull0 = cv2.convexHull(r)
  for h0 in hull0:
    reg0.append(h0[0].tolist())
  reg0.append(reg0[0])

  ring = LinearRing(reg0)
  x, y = ring.xy

  coord_x = int(ring.centroid.x)
  coord_y = int(ring.centroid.y)

  if treated_image[coord_y, coord_x] > 0:
    ax.plot(x, y)
    xrange1 = [0, current_region.shape[1]]
    yrange1 = [0, current_region.shape[0]]
    ax.set_xlim(*xrange1)
    ax.set_ylim(*yrange1)
    ax.imshow(image_pollution, cmap="gray")

    value_pixel = image_pollution[coord_y, coord_x]
    print("value", value_pixel)

    z = np.full(len(x),value_pixel)
    # Data for a three-dimensional line
    ax3d.plot3D(x, y, z)

f, ax = plt.subplots(1, 1, figsize=(11,8))
ax.imshow(image_close, cmap="gray")
ax.invert_yaxis()

f, ax = plt.subplots(1, 1, figsize=(11,8))
ax.imshow(img_bgr, cmap="gray")
ax.invert_yaxis()

perspective = image_pollution.copy()

# create the x and y coordinate arrays (here we just use pixel indices)
xx, yy = np.mgrid[0:perspective.shape[0], 0:perspective.shape[1]]

fig = plt.figure(figsize = (11,8))
ax = Axes3D(fig, elev=30, azim=20)
ax.plot_surface(xx, yy, perspective ,rstride=1, cstride=1, cmap='gray', linewidth=0)
ax.invert_yaxis()









