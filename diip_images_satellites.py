# -*- coding: utf-8 -*-
"""Diip - Images Satellites

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16SvclheI8YAlelhMFv49KGw0zHwfethE

# Import Libraries
"""

#!/bin/env python

import glob
import os
import numpy as np
import numpy.ma as ma
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
plt.rcParams.update({'figure.max_open_warning': 0})
import matplotlib.colors as mcolors
import torch 

import tarfile
import string
import calendar

from google.colab import drive
drive.mount("/content/drive")

#!pip install opencv-python==3.4.2.16
#!pip install opencv-contrib-python==3.4.2.16

import cv2
print(cv2.__version__)

!apt-get install libgeos-3.5.0
!apt-get install libgeos-dev
!pip install https://github.com/matplotlib/basemap/archive/master.zip

from mpl_toolkits.basemap import Basemap,cm

!pip install netcdf4
import netCDF4

!ls

"""# Directory"""

DIR = '/content/drive/MyDrive/StageUParis/DATA/H2O/'
#DIR='/DATA/IASI/EXTERNAL/SUSTAINABLE/DUFOUR/IASIO3daily_PolEASIA/H2O/'

"""# Main Code

Données
- Lattitude
- Longitude
- Valeur
"""

#lat and lon at 0.25 degree resolution
# Try with 0.5 degree
# Check lossing the info and 
latg=np.arange(20.,50.,0.5)
long1=np.arange(100.,150.,0.5)

for year in range(2008,2009):
 for month in range(5,6):
  ndays = calendar.mdays[month] + (month==2 and calendar.isleap(year))
  print(year,month,ndays)
  #for dd in range (1,ndays+1):
  for dd in range (5,8):
   #print("Day #",dd)
   colgrid = np.zeros([latg.shape[0],long1.shape[0]]) #initialization
   fname=DIR+'IASIdaily_'+str(year)+"%02d"%month+"%02d"%dd+'.nc'


   #print("fname",fname)
   #read IASI data in nc archive
   if not(os.path.isfile(fname)):
    continue
   nc = netCDF4.Dataset(fname)
   flg=nc.variables['flag'][:]
   mask1=(flg == 0)

   lat=nc.variables['lat'][mask1]
   lon=nc.variables['lon'][mask1]
   col=nc.variables['LT'][mask1]
   nc.close()
   print('end read nc')

   mask2=(np.isnan(col) == False) 

  # gridding the data
   for ilat in range(latg.shape[0]):
    for ilon in range(long1.shape[0]):
      # Grille régulier
      # 25 km
      # 0 25 degrée lattitude et longitude

      # Grille regulier of 0.125 degree
      maskgrid=(lat[:] >= (latg[ilat] - 0.25)) & (lat[:] < (latg[ilat] + 0.25)) & (lon[:] >= (long1[ilon] - 0.25)) & (lon[:] < (long1[ilon] + 0.25))
      
      # Defining invalid data
      mask = mask2 & maskgrid

      # Add a media filter for the grill regulier
      if len(col[mask]) != 0:
        colgrid[ilat,ilon] = np.mean(col[mask])

   # We mark the values at colgrid as invalid because they are maybe false positives or bad sampling
   colgrid = ma.masked_values(colgrid,0.)
   
   # plot daily maps
   fig=plt.figure(figsize = (11,8))
   plt.subplots_adjust(bottom=0.1,left=0.1,right=0.9,top=0.9)
   
   #------ subplot : IASI LT col
   ax=fig.add_subplot(111)
   p1=plt.subplot(1,1,1)
   
   #### to have coastline and countries in the background of the image
   #m=Basemap(llcrnrlon=100.,llcrnrlat=20.,urcrnrlon=150.,urcrnrlat=48.,resolution='i')
   #m.drawcoastlines()
   #m.drawmapboundary()
   #m.drawmeridians(np.r_[100:151:10], labels=[0,0,0,1], color='grey',fontsize=8,linewidth=0)
   #m.drawparallels(np.r_[20:48:5], labels=[1,0,0,0], color='grey',fontsize=8,linewidth=0)

   cs=plt.pcolor(long1,latg,colgrid,vmin=1,vmax=15)#,cmap=plt.cm.Greys) #check whether it is at the center
   c=plt.colorbar(cs)#,location='bottom',pad="10%")
   c.set_label("[DU]",fontsize=10)
   c.ax.tick_params(labelsize=8)
   sbpt="IASI LT ozone column "+str(year)+"%02d"%month+"%02d"%dd
   plt.title(sbpt,fontsize=10)

   figname="Daily_IASI_gridded_raw."+str(year)+"%02d"%month+"%02d"%dd+".png"
   #figname="Daily_IASI_gridded_grey_raw."+str(year)+"%02d"%month+"%02d"%dd+".png"
   #print("figname",figname)
   plt.savefig(figname)
   plt.clf()
   
 print('end month')

def plot_sequence_images(degree = .25, size = .125, vmin = 7, vmax = 30):
  latg=np.arange(20.,50.,degree)
  long1=np.arange(100.,150.,degree)
  
  for year in range(2008,2009):
    for month in range(5,6):
      ndays = calendar.mdays[month] + (month==2 and calendar.isleap(year))
      print(year,month,ndays)

      for dd in range (5,8):
        colgrid = np.zeros([latg.shape[0],long1.shape[0]]) #initialization
        fname=DIR+'IASIdaily_'+str(year)+"%02d"%month+"%02d"%dd+'.nc'
        #print("fname",fname)
        #read IASI data in nc archive
        if not(os.path.isfile(fname)):
          continue
        nc = netCDF4.Dataset(fname)
        flg=nc.variables['flag'][:]
        mask1=(flg == 0)

        lat=nc.variables['lat'][mask1]
        lon=nc.variables['lon'][mask1]
        col=nc.variables['LT'][mask1]
        nc.close()
      
        print('end read nc')

        mask2=(np.isnan(col) == False) 

        # gridding the data
        for ilat in range(latg.shape[0]):
          for ilon in range(long1.shape[0]):
            # Grille régulier
            # 25 km
            # 0 25 degrée lattitude et longitude

            # Grille regulier of 0.125 degree
            maskgrid=(lat[:] >= (latg[ilat] - size)) & (lat[:] < (latg[ilat] + size)) & (lon[:] >= (long1[ilon] - size)) & (lon[:] < (long1[ilon] + size))
            
            # Defining invalid data
            mask = mask2 & maskgrid

            #print("the col", col[mask])

            # Add a media filter for the grill regulier
            if len(col[mask]) != 0:
              median = np.mean(col[mask])
              if (median >= vmin):
                colgrid[ilat,ilon] = median
              
        # We mark the values at colgrid as invalid because they are maybe false positives or bad sampling
        colgrid = ma.masked_values(colgrid,0.)
        
        # plot daily maps
        fig = plt.figure(figsize = (11,8))
        plt.subplots_adjust(bottom=0.1,left=0.1,right=0.9,top=0.9)
        
        #------ subplot : IASI LT col
        ax=fig.add_subplot(111)
        p1=plt.subplot(1,1,1)
        
        #### to have coastline and countries in the background of the image
        #m=Basemap(llcrnrlon=100.,llcrnrlat=20.,urcrnrlon=150.,urcrnrlat=48.,resolution='i')
        #m.drawcoastlines()
        #m.drawmapboundary()
        #m.drawmeridians(np.r_[100:151:10], labels=[0,0,0,1], color='grey',fontsize=8,linewidth=0)
        #m.drawparallels(np.r_[20:48:5], labels=[1,0,0,0], color='grey',fontsize=8,linewidth=0)

        cs=plt.pcolor(long1,latg,colgrid,vmin=vmin,vmax=vmax, cmap="jet")#,cmap=plt.cm.Greys) #check whether it is at the center
        c=plt.colorbar(cs)#,location='bottom',pad="10%")
        c.set_label("[DU]",fontsize=10)
        c.ax.tick_params(labelsize=8)
        sbpt="IASI LT ozone column "+str(year)+"%02d"%month+"%02d"%dd
        plt.title(sbpt,fontsize=10)
        figname=str(year)+"%02d"%month+"%02d"%dd+"_deg-"+str(degree)+"_size-"+str(size)+"_vmin-"+str(vmin)+"_vmax-"+str(vmax)+".png"
        #plt.plot(figname)
        plt.savefig(figname)
    
  print('end month')

# Echelle 07+14

deg = .125
size = .0625
  
for i in range(10):
  if (i==0):
    continue

  deg2 = deg * i
  size2 = (deg2 * size) /  deg
  vmin = round(i * 0.9)
  vmax = round(30 - i)  

  print(deg2,size2,vmin,vmax)
  plot_sequence_images(degree = .25, size = .125, vmin = (i+7), vmax = 30)
  print("\n---------------\n")

# Echelle 21-30

deg = .125
size = .0625
  
for i in range(10):
  if (i==0):
    continue

  deg2 = deg * i
  size2 = (deg2 * size) /  deg
  vmin = round(i * 0.9)
  vmax = round(30 - i)  

  print(deg2,size2,vmin,vmax)
  plot_sequence_images(degree = .25, size = .125, vmin = 7, vmax = vmax)
  print("\n---------------\n")

plot_sequence_images(degree = .25, size = .125, vmin = 7, vmax = 30)

plot_sequence_images(degree = .5, size = .25, vmin = 1, vmax = 20)

plot_sequence_images(degree = 1.5, size = .5, vmin = 1, vmax = 20)

plot_sequence_images(degree = 2, size = 1, vmin = 1, vmax = 10)