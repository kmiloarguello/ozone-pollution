# -*- coding: utf-8 -*-
"""Diip - Images Satellites

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16SvclheI8YAlelhMFv49KGw0zHwfethE

# Import Libraries
"""

#!/bin/env python

import glob
import os
import numpy as np
import numpy.ma as ma
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
plt.rcParams.update({'figure.max_open_warning': 0})
import matplotlib.colors as mcolors
from scipy.interpolate import griddata
import torch
from PIL import Image

import tarfile
import string
import calendar

from google.colab import drive
drive.mount("/content/drive")

#!pip install opencv-python==3.4.2.16
#!pip install opencv-contrib-python==3.4.2.16

import cv2
from google.colab.patches import cv2_imshow
print(cv2.__version__)

!apt-get install libgeos-3.5.0
!apt-get install libgeos-dev
!pip install https://github.com/matplotlib/basemap/archive/master.zip

!pip install http://sourceforge.net/projects/matplotlib/files/matplotlib-toolkits/

from mpl_toolkits.basemap import Basemap,cm

!pip install netcdf4
import netCDF4

!ls

"""# Directory"""

DIR = '/content/drive/MyDrive/StageUParis/DATA/H2O/'
#DIR='/DATA/IASI/EXTERNAL/SUSTAINABLE/DUFOUR/IASIO3daily_PolEASIA/H2O/'

"""# Main Code

Données
- Lattitude
- Longitude
- Valeur
"""

def _annotate2(ax, x, y):
  # this all gets repeated below:
  X, Y = np.meshgrid(x, y)
  ax.plot(X.flat, Y.flat, 'o', color='m')

def plot_sequence_images(degree = .25, size = .125, thres=7):
  lat_g = np.arange(20.,50.,degree)
  lon_g = np.arange(100.,150.,degree)

  for year in range(2008,2009):
    for month in range(5,6):
      ndays = calendar.mdays[month] + (month==2 and calendar.isleap(year))
      print(year,month,ndays)

      for dd in range (6,7):
        #initialization
        colgrid = np.zeros([lat_g.shape[0],lon_g.shape[0]], np.float32)
        fname = DIR+'IASIdaily_'+str(year)+"%02d"%month+"%02d"%dd+'.nc'

        #read IASI data in nc archive
        if not(os.path.isfile(fname)):
          continue

        nc = netCDF4.Dataset(fname)
        flg = nc.variables['flag'][:]
        mask1 = (flg == 0)

        lat = nc.variables['lat'][mask1]
        lon = nc.variables['lon'][mask1]
        col = nc.variables['LT'][mask1]
        nc.close()
      
        print('end read nc')

        mask2 = (np.isnan(col) == False) 

        # gridding the data
        for ilat in range(lat_g.shape[0]):
          for ilon in range(lon_g.shape[0]):
            # Grille régulier
            # 25 km
            # 0 25 degrée lattitude et longitude

            # Grille regulier of 0.125 degree
            maskgrid = (lat[:] >= (lat_g[ilat] - size)) & (lat[:] < (lat_g[ilat] + size)) & (lon[:] >= (lon_g[ilon] - size)) & (lon[:] < (lon_g[ilon] + size))
            
            # Defining invalid data
            mask = mask2 & maskgrid

            # Add a media filter for the grill regulier
            isMask = (len(col[mask]) != 0) & (col[mask] >= thres).all()

            if len(col[mask]) != 0:
              median = np.mean(col[mask])
              #if (median >= vmin):
              colgrid[ilat,ilon] = median
              
        # We mark the values at colgrid as invalid because they are maybe false positives or bad sampling
        colgrid = ma.masked_values(colgrid, 0.)

        #for i in lon_g:
        #  print("lon_g",i)

        #print("---------------------")
        
        #for i in lat_g:
        #  print("lat_g",i)

        #print("---------------------")

        #for i in colgrid:
        #  print(type(i))

        print(colgrid)

        vis2 = cv2.cvtColor(colgrid, cv2.COLOR_GRAY2BGR)
        plt.figure(figsize=(10,10))
        #plt.axis("off")
        plt.imshow(vis2)
        plt.show()

        #triang = tri.Triangulation(x, y)
        #interpolator = tri.LinearTriInterpolator(triang, z)
        #Xi, Yi = np.meshgrid(lon_g, lat_g)
        #zi = interpolator(Xi, Yi)

        #fig, ax = plt.subplots(figsize = (11,8), ncols=2)
        fig, ax1 = plt.subplots(1, 1, figsize = (11,8))
        ax1.pcolormesh(lon_g, lat_g, colgrid, shading='nearest',cmap="Greys", vmin=colgrid.min(), vmax=colgrid.max())
        #ax1.contour(lon_g, lat_g, colgrid, cmap="jet", linewidths = 2, levels=30 )
        #ax2.hist(colgrid)

        #figname=str(year)+"%02d"%month+"%02d"%dd+"_deg-"+str(degree)+"_size-"+str(size)+"_vmin-"+str(vmin)+"_vmax-"+str(vmax)+".png"

        #im = cv2.imread(source_image)
        #print(im)

        #_annotate2(ax_, lon_g, lat_g)
        
        
    
  print('end month')

deg = .125
size = .0625
  
for i in range(40,41):
  if (i==0):
    continue

  deg2 = deg * i
  size2 = (deg2 * size) /  deg
  print(deg2,size2)
  plot_sequence_images(degree = 5.0, size = 2.5, thres=(i-20))

x=np.linspace(1.,10.,20)
y=np.linspace(1.,10.,20)
z=z = np.random.random(20)
xi=np.linspace(1.,10.,10)
yi=np.linspace(1.,10.,10)

X,Y= np.meshgrid(xi,yi)

print(x.shape,y.shape, z.shape)

#Z = griddata((x, y), z, (X, Y),method='nearest')
#plt.contour(X,Y,Z)

import matplotlib.tri as tri

np.random.seed(19680801)
npts = 200
ngridx = 100
ngridy = 200
x = np.random.uniform(-2, 2, npts)
y = np.random.uniform(-2, 2, npts)
z = x * np.exp(-x**2 - y**2)

fig, (ax1, ax2) = plt.subplots(nrows=2)

# -----------------------
# Interpolation on a grid
# -----------------------
# A contour plot of irregularly spaced data coordinates
# via interpolation on a grid.

# Create grid values first.
xi = np.linspace(-2.1, 2.1, ngridx)
yi = np.linspace(-2.1, 2.1, ngridy)

# Linearly interpolate the data (x, y) on a grid defined by (xi, yi).
triang = tri.Triangulation(x, y)
interpolator = tri.LinearTriInterpolator(triang, z)
Xi, Yi = np.meshgrid(xi, yi)
zi = interpolator(Xi, Yi)

print(zi.shape)

# Note that scipy.interpolate provides means to interpolate data on a grid
# as well. The following would be an alternative to the four lines above:
#from scipy.interpolate import griddata
#zi = griddata((x, y), z, (xi[None, :], yi[:, None]), method='linear')

ax1.contour(xi, yi, zi, levels=14, linewidths=0.5, colors='k')
ax1.set(xlim=(-2, 2), ylim=(-2, 2))
ax1.set_title('grid and contour (%d points, %d grid points)' %
              (npts, ngridx * ngridy))

# ----------
# Tricontour
# ----------
# Directly supply the unordered, irregularly spaced coordinates
# to tricontour.

ax2.tricontour(x, y, z, levels=14, linewidths=0.5, colors='k')
cntr2 = ax2.tricontourf(x, y, z, levels=14, cmap="RdBu_r")

ax2.plot(x, y, 'ko', ms=3)
ax2.set(xlim=(-2, 2), ylim=(-2, 2))
ax2.set_title('tricontour (%d points)' % npts)

plt.subplots_adjust(hspace=0.5)
plt.show()

np.random.seed(8)
ndata = 10
ny, nx = 100, 200
xmin, xmax = 1, 10
ymin, ymax = 1, 10
x = np.linspace(1, 10, ndata)
y = np.linspace(1, 10, ndata)
z = np.random.random(ndata)
x = np.r_[x,xmin,xmax]
y = np.r_[y,ymax,ymin]
z = np.r_[z,z[0],z[-1]]
xi = np.linspace(xmin, xmax, nx)
yi = np.linspace(ymin, ymax, ny)

print(np.linspace(1, 10, ndata))

X,Y= np.meshgrid(xi,yi)
Z = griddata((x, y), z, (X, Y),method='nearest')
plt.contour(X,Y,Z)

vis = np.zeros((384, 836), np.float32)
vis2 = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)

print(vis.shape,vis2.shape)

